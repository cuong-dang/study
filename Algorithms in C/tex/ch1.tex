\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amsthm, enumitem, listings}

\everymath{\displaystyle}
\newtheorem{property}{Property}
\numberwithin{property}{section}

\title{Algorithms in C}
\author{}
\date{}

\begin{document}
\maketitle
\section{Introduction}
\subsection{Algorithms}
\subsection{A Sample Problem: Connectivity}
\subsubsection*{Exercises}
\begin{enumerate}[label=1-\arabic*]
      \item
            \begin{lstlisting}
          0-2
          1-4
          2-5
          3-6
          0-4
          6-0
          \end{lstlisting}
      \item
      \item Initialize \textit{count} to be N for N objects. Iterate through the pairs. For each
            \textit{union} call, decrease \textit{count} by 1.
\end{enumerate}

\subsection{Union-Find Algorithms}
\begin{property}
      The quick-find algorithm executes at least $MN$ instructions to solve a connectivity problem
      with $N$ objects that involves $M$ \textup{union} operations.
\end{property}
\begin{proof}
      For each of the $M$ \textit{union} operations, we iterate the \texttt{for} loop $N$ times.
      Each iteration requires at least one instruction (if only to check whether the loop is
      finished).
\end{proof}
\begin{property}
      For $M > N$, the quick-union algorithm could take more than $MN/2$ instructions to solve a
      connectivity problem with $M$ pairs of $N$ objects.
\end{property}
\begin{proof}
      Suppose that the input pairs come in the order $1-2$, then $2-3$, then $3-4$, and so forth.
      After $N-1$ such pairs, we have $N$ objects all in the same set, and the tree that is formed
      by the quick-union algorithmis a straight line, with $N$ pointing to $N-1$, which points to
      $N-2$, which points to $N-3$, and so forth. To execute the \textit{find} operation for object
      $N$, the program has to follow $N-1$ pointers. Thus, the average number of pointers followed
      for the first $N$ pairs is
      \[(0 + 1 + \ldots + (N-1))/N = (N-1)/2.\]
      Now suppose that the remainder of the pairs all connect $N$ to some other object. The
      \textit{find} operation for each of these pairs involves at least $(N-1)$ pointers. The grand
      total for the $M$ \textit{find} operations for this sequence of input pairs is certainly
      greater than $MN/2$.
\end{proof}
\paragraph{Note} The $N^{th}$ pair should connect $N$ with $1$ for the above formula to be correct.
We want to show why the total number of pointers is greater than $MN/2$, as it is not obviously
clear to me from the text. Since we are proving the worst case, we can assume that of the
remaining pairs, there exists the pair $N$-$N$, which will result in $2(N-1)$ pointer operations.
Thus, if we call the total number of pointer follows $T$, then we have
\[T \ge N(N-1)/2 + (M-N-1)(N-1) + 2(N-1) = N(N-1)/2 + (M-N+1)(N-1).\]
For all $N > 1$, $N-1 > N/2$. Therefore,
\[T \ge N(N-1)/2 + (M-N+1)(N-1) > (N-1)N/2 + (M-N+1)N/2 = MN/2.\]
\begin{property}\label{prop:wqu}
      The weighted quick-union algorithm follows at most $2\lg{N}$ pointers to determine whether two
      of $N$ objects are connected.
\end{property}
\begin{proof}
      We can prove that the \textit{union} operation preserves the property that the number of
      pointers followed from any node to the root in a set of $k$ objects is no greater than
      $\lg{k}$ (we do not count the self-pointer at the root). When we combine a set of $i$ nodes
      with a set of $j$ nodes with $i \le j$, we increase the number of pointers that must be
      followed in the smaller set by 1, but they are now in a set of size $i+j$, so the property
      is preseved because $1 + \lg{i} = \lg(i+i) \le \lg(i+j)$.
\end{proof}
\paragraph{Note} The above proof can be seen as a proof by induction with $n$ as the number of the
\textit{union} operations and the inductive hypothesis as for sets of size $k$, the number of
pointers followed from any node is no greater than $\lg{k}$.
\paragraph{Note} The practical implication of Property~\ref{prop:wqu} is that the weighted
quick-union algorithm uses \emph{at most} a constant times $M\lg{N}$ instructions to process $M$
edges (i.e., $M$ \textit{union} operations) on $N$ objects. This result is in stark constrast to our
finding that quick find always (and quick union sometimes) uses \emph{at least} $MN/2$ instructions.
\end{document}
