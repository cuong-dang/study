(Define balance 100)

(define (withdraw amount)
  (if (>= balance amount)
	  (begin (set! balance (- balance amount))
			 balance)
	  "Insufficient funds"))

(define new-withdraw
  (let ((balance 100))
	(lambda (amount)
	  (if (>= balance amount)
		  (begin (set! balance (- balance amount))
				 balance)
		  "Insufficient funds"))))

(define (make-withdraw balance)
  (lambda (amount)
	(if (>= balance amount)
		(begin (set! balance (- balance amount))
			   balance)
		"Insufficient funds")))

(define (make-account balance master-password)
  (let ((passwords (list master-password))
		(past-consecutive-password-failures 0))
	(define (withdraw amount)
	  (if (>= balance amount)
		  (begin (set! balance (- balance amount))
				 balance)
		  "Insufficient funds"))
	(define (deposit amount)
	  (set! balance (+ balance amount))
	  balance)
	(define (add-joint new-pw)
	  (set! passwords (cons new-pw passwords))
	  dispatch)
	(define (call-the-cops) (display "Cops called"))
	(define dispatch
	  (lambda (p m)
		(cond ((null? (memq p passwords))
			   (if (= past-consecutive-password-failures 7)
				   (call-the-cops)
				   (begin (set! past-consecutive-password-failures
								(+ past-consecutive-password-failures 1))
						  (error "Incorrect password"))))
			  ((eq? m 'add-joint)
			   (if (eq? p master-password)
				   add-joint
				   (error "Incorrect master password")))
			  (else
			   (begin (set! past-consecutive-password-failures 0)
					  (cond ((eq? m 'withdraw) withdraw)
							((eq? m 'deposit) deposit)
							(else (error "Unknown request -- MAKE-ACCOUNT"
										 m))))))))
  dispatch))

(define (make-accumulator init-sum)
  (let ((sum init-sum))
	(lambda (amount)
	  (set! sum (+ sum amount))
	  sum)))

(define (make-monitored f)
  (let ((num-calls 0))
	(lambda (x)
	  (cond ((eq? x 'how-many-calls?) num-calls)
			((eq? x 'reset-count)
			 (set! num-calls 0)
			 num-calls)
			(else (begin (set! num-calls (+ num-calls 1))
						 (f x)))))))

;;3.1.2 The Benefits of Introducing Assignment
(define rand
  (let ((x 0))
	(lambda (m)
	  (cond ((eq? m 'generate)
			 (set! x (rand-update x))
			 x)
			((eq? m 'reset)
			 (lambda (new-value)
			   (set! x (rand-update new-value))
			   x))
			(else (error "Unknown request -- RAND"))))))

(define (estimate-pi trials)
  (define (in-unit-circle-test x y)
	(le (+ (square x) (square y)) 1))
  (exact->inexact (estimate-integral in-unit-circle-test -2 2 -2 2 trials)))

(define (le x y)
  (or (< x y) (= x y)))

(define (cesaro-test)
  (= (gcd (random 1000000000) (random 1000000000)) 1))

(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
	(cond ((= trials-remaining 0)
		   (/ trials-passed trials))
		  ((experiment)
		   (iter (- trials-remaining 1) (+ trials-passed 1)))
		  (else
		   (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))

(define (random-gcd-test trials initial-x)
  (define (iter trials-remaining trials-passed x)
	(let ((x1 (rand-update x)))
	  (let ((x2 (rand-update x1)))
		(cond ((= trials-remaining 0)
			   (/ trials-passed trials))
			  ((= (gcd x1 x2) 1)
			   (iter (- trials-remaining 1)
					 (+ trials-passed 1)
					 x2))
			  (else
			   (iter (- trials-remaining 1)
					 trials-passed
					 x2)))))))

(define (random-in-range low high)
  (let ((range (- high low)))
	(+ low (random range))))

(define (rec-area x1 x2 y1 y2)
  (* (abs (- x2 x1)) (abs (- y2 y1))))

(define (estimate-integral p x1 x2 y1 y2 trials)
  (define (random-in-range-scaled low high scale-factor)
		(/ (random-in-range (* low scale-factor) (* high scale-factor))
			 scale-factor))
  (define (experiment)
		(let ((x (random-in-range-scaled x1 x2 100))
					(y (random-in-range-scaled y1 y2 100)))
			(p x y)))
  (let ((mc-result (monte-carlo trials experiment)))
		(* mc-result (rec-area x1 x2 y1 y2))))

;;3.1.3 The Costs of Introducing Assignment
(define (make-simplified-withdraw balance)
  (lambda (amount)
	(set! balance (- balance amount))
	balance))

(define (make-decrementer balance)
  (lambda (amount)
	(- balance amount)))

(define (make-joint old-acc master-pw new-pw)
  ((old-acc master-pw 'add-joint ) new-pw))

(define f
  (let ((untouched true))
	(lambda (x)
	  (cond ((and untouched (= x 0))
			 (set! untouched false)
			 0)
			((and (not untouched) (= x 0))
			 0)
			((and untouched (= x 1))
			 (set! untouched false)
			 1)
			((and (not untouched (= x 1)))
			 0)))))

;;;The Environment Model of Evaluation
;;3.2.1 The Rules for Evaluation
;;3.2.2 Applying Simple Procedures
;;3.2.3 Frames as the Repository of Local State
;;3.2.4 Internal Definitions
;3.3 Modeling with Mutable Data
;; (define (cons x y)
;;   (let ((new (get-new-pair)))
;; 	(set-car! new x)
;; 	(set-cdr! new y)
;; 	new))
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
(define (last-pair x)
  (if (null? (cdr x))
	  x
	  (last-pair (cdr x))))
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
(define (reverse! x)
  (define (loop x y)
	(if (null? x)
		y
		(let ((temp (cdr x)))
		  (set-cdr! x y)
		  (loop temp x))))
  (loop x '()))
(define count-pairs
  (let ((traversed '()))
	(lambda (x)
	  (cond ((not (pair? x)) 0)
			((not (memq x traversed))
			 (set! traversed (cons x traversed))
			 (+ (count-pairs (car x))
				(count-pairs (cdr x))
				1))
			(else (+ (count-pairs (car x))
					 (count-pairs (cdr x))))))))
(define infty-cdr?
  (let ((traversed '()))
	(define (traverse x)
	  (cond ((not (pair? x)) false)
			((memq x traversed) true)
			(else (set! traversed (cons x traversed))
				  (traverse (cdr x)))))
	traverse))
(define (infty-cdr? x)
  (define (iter turtle hare)
	(cond ((not (pair? turtle)) false)
		  ((not (pair? hare)) false)
		  ((not (pair? (cdr hare))) false)
		  ((eq? turtle hare) true)
		  (else (iter (cdr turtle) (cddr hare)))))
  (cond ((not (pair? x)) false)
		((not (pair? (cddr x))) false)
		(else (iter (cdr x) (cddr x)))))
(define (other-cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
	(cond ((eq? m 'car) x)
		  ((eq? m 'cdr) y)
		  ((eq? m 'set-car!) set-x!)
		  ((eq? m 'set-cdr!) set-y!)
		  (else (error "Undefined operation -- OTHER-CONS" m))))
  dispatch)
;;3.3.2 Representing Queues
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (make-queue) (cons '() '()))
(define (front-queue queue)
  (if (empty-queue? queue)
	  (error "FRONT called with an empty queue" queue)
	  (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
	(cond ((empty-queue? queue)
		   (set-front-ptr! queue new-pair)
		   (set-rear-ptr! queue new-pair)
		   queue)
		  (else
		   (set-cdr! (rear-ptr queue) new-pair)
		   (set-rear-ptr! queue new-pair)
		   queue))))
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
		 (error "DELETE! called with an empty queue" queue))
		(else
		 (set-front-ptr! queue (cdr (front-ptr queue)))
		 queue)))
(define (print-queue queue)
  (car queue))
(define (make-dqueue)
  (let ((front-ptr '())
		(rear-ptr '()))
	(define (make-dqitem item)
	  (let ((content item) (prev '()))
		(list (cons content prev))))
	(define (empty-dqueue?) (null? front-ptr))
	(define (front-dqueue)
	  (cond ((empty-dqueue?)
			 (error "FRONT called with an empty queue"))
			(else
			 (caar front-ptr))))
	(define (rear-dqueue)
	  (cond ((empty-dqueue?)
			 (error "REAR called with an empty queue"))
			(else
			 (caar rear-ptr))))
	(define (rear-insert-dqueue! item)
	  (let ((new-item (make-dqitem item)))
		(cond ((empty-dqueue?)
			   (set! front-ptr new-item)
			   (set! rear-ptr new-item))
			  (else
			   (set-cdr! (car new-item) rear-ptr)
			   (set-cdr! rear-ptr new-item)
			   (set! rear-ptr new-item)))))
	(define (front-insert-dqueue! item)
	  (let ((new-item (make-dqitem item)))
		(cond ((empty-dqueue?)
			   (rear-insert-dqueue! item))
			  (else
			   (set-cdr! (car front-ptr) new-item)
			   (set-cdr! new-item front-ptr)
			   (set! front-ptr new-item)))))
	(define (front-delete-dqueue!)
	  (cond ((empty-dqueue?)
			 (error "DELETE! called with an empty queue"))
			(else
			 (let ((next (cdr front-ptr)))
			   (set! front-ptr next)))))
	(define (rear-delete-dqueue!)
	  (cond ((empty-dqueue?)
			 (error "DELETE! called with an empty queue"))
			((eq? front-ptr rear-ptr) ; very ugly case
			 (front-delete-dqueue!))
			(else
			 (let ((prev (cdar rear-ptr)))
			   (set! rear-ptr prev)
			   (set-cdr! prev '())))))
	(define (print-dqueue)
	  (map car front-ptr))
	(define (dispatch m)
	  (cond ((eq? m 'empty-dqueue?) empty-dqueue?)
			((eq? m 'front-dqueue) front-dqueue)
			((eq? m 'rear-dqueue) rear-dqueue)
			((eq? m 'front-insert-dqueue!) front-insert-dqueue!)
			((eq? m 'rear-insert-dqueue!) rear-insert-dqueue!)
			((eq? m 'front-delete-dqueue!) front-delete-dqueue!)
			((eq? m 'rear-delete-dqueue!) rear-delete-dqueue!)
			((eq? m 'print-dqueue) print-dqueue)))
	dispatch))
;;DEBUG
(define q (make-dqueue))
((q 'front-insert-dqueue!) 1)
((q 'front-insert-dqueue!) 2)
((q 'rear-insert-dqueue!) 3)
((q 'front-delete-dqueue!))
((q 'print-dqueue))
((q 'rear-delete-dqueue!))
((q 'print-dqueue))
((q 'front-delete-dqueue!))
((q 'print-dqueue))
((q 'front-insert-dqueue!) 1)
((q 'rear-delete-dqueue!))
((q 'print-dqueue))
;;3.3.3 Representing Tables
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
	(if record
		(cdr record)
		false)))
(define (assoc key records)
  (cond ((null? records) false)
		((equal? key (caar records)) (car records))
		(else (assoc key (cdr records)))))
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
	(if record
		(set-cdr! record value)
		(set-cdr! table
				  (cons (cons key value) (cdr table)))))
  'ok)
(define (make-table)
  (list '*table*))
(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
	(if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
			  (cdr record)
			  false))
		false)))
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
	(if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
			  (set-cdr! record value)
			  (set-cdr! subtable
						(cons (cons key-2 value)
							  (cdr subtable)))))
		(set-cdr! table
				  (cons (list key-1
							  (cons key-2 value))
						(cdr table)))))
  'ok)
(define (make-table key key=? key<?)
  (let ((local-table (cons '*table* (make-tree key key=? key<?))))
	(define (assoc lookup-key records)
	  ((records 'lookup-proc) lookup-key))
	(define (gen-subtables keys value)
	  (let ((table (make-tree key key=? key<?)))
		(cond ((= (length keys) 1)
			   ((table 'insert-proc!) (cons (car keys) value))
			   table)
			  (else
			   ((table 'insert-proc!) (cons (car keys)
											(gen-subtables (cdr keys) value)))
			   table))))
	(define (lookup keys)
	  (define (iter keys search-result)
		(cond ((null? keys)
			   (cdr search-result))
			  ((not (procedure? (cdr search-result))) false)
			  (else
			   (let ((next-search (assoc (car keys) (cdr search-result))))
				 (if next-search
					 (iter (cdr keys) next-search)
					 false)))))
	  (iter keys local-table))
	(define (insert! keys value)
	  (define (iter keys value search-result)
		(cond ((null? keys)
			   (set-cdr! search-result value))
			  ((not (procedure? (cdr search-result)))
			   (set-cdr! search-result (gen-subtables keys value)))
			  (else
			   (let ((next-search (assoc (car keys) (cdr search-result))))
				 (if next-search
					 (iter (cdr keys) value next-search)
					 (set-cdr! search-result
					  (gen-subtables keys value)))))))
	  (iter keys value local-table)
	  'ok)
	(define (print) local-table)
	(define (dispatch m)
	  (cond ((eq? m 'lookup-proc) lookup)
			((eq? m 'insert-proc!) insert!)
			((eq? m 'print-proc) print)
			(else (error "Unknown operation -- TABLE" m))))
	dispatch))
(define (make-tree key key=? key<?)
  (define local-tree (list (list) (list) (list)))
  (define (left-branch tree) (cadr tree))
  (define (right-branch tree) (caddr tree))
  (define (leaf tree) (car tree))
  (define (insert! item)
	(define (iter tree)
	  (cond ((null? (leaf tree)) (set-car! tree item))
			((key<? (key item) (key (leaf tree)))
			 (if (null? (left-branch tree))
				 (set-cdr! tree (list (list item '() '()) (right-branch tree)))
				 (iter (left-branch tree))))
			((key=? (key item) (key (leaf tree)))
			 'dup)
			(else
			 (if (null? (right-branch tree))
				 (set-cdr! tree (list (left-branch tree) (list item '() '())))
				 (iter (right-branch tree))))))
	(iter local-tree)
	'ok)
  (define (lookup lookup-key)
	(define (iter tree)
	  (cond ((null? (leaf tree)) false)
			((key=? lookup-key (key (leaf tree))) (leaf tree))
			((key<? lookup-key (key (leaf tree)))
			 (if (null? (left-branch tree))
				 false
				 (iter (left-branch tree))))
			(else
			 (if (null? (right-branch tree))
				 false
				 (iter (right-branch tree))))))
	(iter local-tree))
  (define (print) local-tree)
  (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
		  ((eq? m 'insert-proc!) insert!)
		  ((eq? m 'print-proc) print)
		  (else (error "Unknown operation -- TREE" m))))
	dispatch)
;;DEBUG
(define (key item) (car item))
(define (key=? k1 k2) (eq? k1 k2))
(define (key<? k1 k2) (string<? (symbol->string k1) (symbol->string k2)))
(define tab (make-table key key=? key<?))
((tab 'insert-proc!) '(fender) 1)
((tab 'lookup-proc) '(fender))
((tab 'insert-proc!) '(prs) 2)
((tab 'lookup-proc) '(prs))
((tab 'insert-proc!) '(gibson lp) 3)
((tab 'lookup-proc) '(gibson lp))
((tab 'lookup-proc) '(gibson))
((tab 'insert-proc!) '(gibson sg) 4)
((tab 'lookup-proc) '(gibson sg))
((tab 'insert-proc!) '(fender strat) 5)
((tab 'lookup-proc) '(fender))
((tab 'lookup-proc) '(fender strat))
((tab 'insert-proc!) '(gibson) 6)
((tab 'lookup-proc) '(gibson))
;;3.3.4 A Simulator for Digital Circuits
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
	(or-gate a b d)
	(and-gate a b c)
	(inverter c e)
	(and-gate d e s)
	'ok))
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
		(c1 (make-wire))
		(c2 (make-wire)))
	(half-adder b c-in s c1)
	(half-adder a s sum c2)
	(or-gate c1 c2 c-out)
	'ok))
;;Primitive function boxes
(define (inverter input output)
  (define (invert-input)
	(let ((new-value (logical-not (get-signal input))))
	  (after-delay inverter-delay
				   (lambda ()
					 (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
		((= s 1) 0)
		(else (error "Invalid signal" s))))
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
	(let ((new-value
		   (logical-and (get-signal a1) (get-signal a2))))
	  (after-delay and-gate-delay
				   (lambda ()
					 (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
(define (logical-and pred1 pred2)
  (and pred1 pred2))
(define (or-gate a1 a2 output)
  (define (or-action-procedure)
	(let ((new-value
		   (logical-or (get-signal a1) (get-signal a2))))
	  (after-delay or-gate-delay
				   (lambda ()
					 (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)
(define (logical-or pred1 pred2)
  (or pred1 pred2))
(define (or-gate-composite a1 a2 output)
  (define (or-composite-action-procedure)
	(let ((invert-a1 (make-wire))
		  (invert-a2 (make-wire))
		  (and-output (make-wire)))
	  (inverter a1 invert-a1)
	  (inverter a2 invert-a2)
	  (and-gate invert-a1 invert-a2 and-output)
	  (inverter and-output output)))
  (add-action! a1 or-composite-procedure)
  (add-action! a2 or-composite-procedure)
  'ok)
(define (ripple-carry-adder a-wires b-wires c s-wires)
  (if (null? a-wires)
	  'ok
	  (let ((c-out (make-wire)))
		(full-adder (car a-wires) (car b-wires) c (car s-wires) c-out)
		(ripple-carry-adder (cdr a-wires) (cdr b-wires) c-out (cdr s-wires)))))
;;Representing wires
(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
	(define (set-my-signal! new-value)
	  (if (not (= signal-value new-value))
		  (begin (set! signal-value new-value)
				 (call-each action-procedures))
		  'done))
	(define (accept-action-procedure! proc)
	  (set! action-procedures (cons proc action-procedures))
	  (proc))
	(define (dispatch m)
	  (cond ((eq? m 'get-signal) signal-value)
			((eq? m 'set-signal!) set-my-signal!)
			((eq? m 'add-action!) accept-action-procedure!)
			(else (error "Unknown operation -- WIRE" m))))
	dispatch))
(define (call-each procedures)
  (if (null? procedures)
	  'done
	  (begin
		((car procedures))
		(call-each (cdr procedures)))))
(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
;;The agenda
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
				  action
				  the-agenda))
(define (propagate)
  (if (empty-agenda? the-agenda)
	  'done
	  (let ((first-item (first-agenda-item the-agenda)))
		(first-item)
		(remove-first-agenda-item! the-agenda)
		(propagate))))
(define (probe name wire)
  (add-action! wire
			   (lambda ()
				 (newline)
				 (display name)
				 (display " ")
				 (display (current-time the-agenda))
				 (display "  New-value = ")
				 (display (get-signal wire)))))
;;Implementing the agenda
(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))
(define (empty-agenda? agenda)
  (null? (segments agenda)))
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
	(or (null? segments)
		(< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
	(let ((q (make-queue)))
	  (insert-queue! q action)
	  (make-time-segment time q)))
  (define (add-to-segments! segments)
	(if (= (segment-time (car segments)) time)
		(insert-queue! (segment-queue (car segments))
					   action)
		(let ((rest (cdr segments)))
		  (if (belongs-before? rest)
			  (set-cdr!
			   segments
			   (cons (make-new-time-segment time action)
					 (cdr segments)))
			  (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
	(if (belongs-before? segments)
		(set-segments!
		 agenda
		 (cons (make-new-time-segment time action)
			   segments))
		(add-to-segments! segments))))
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
	(delete-queue! q)
	(if (empty-queue? q)
		(set-segments! agenda (rest-segments agenda)))))
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
	  (error "Agenda is empty -- FIRST-AGENDA-ITEM")
	  (let ((first-seg (first-segment agenda)))
		(set-current-time! agenda (segment-time first-seg))
		(front-queue (segment-queue first-seg)))))
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))
(probe 'sum sum)
(probe 'carry carry)
(half-adder input-1 input-2 sum carry)
(set-signal! input-1 1)
(propagate)
(set-signal! input-2 1)
(propagate)
;;3.3.5 Propagation of Constraints
;;Implementing the constraint system
(define (adder a1 a2 sum)
  (define (process-new-value)
	(cond ((and (has-value? a1) (has-value? a2))
		   (set-value! sum
					   (+ (get-value a1) (get-value a2))
					   me))
		  ((and (has-value? a1) (has-value? sum))
		   (set-value! a2
					   (- (get-value sum) (get-value a1))
					   me))
		  ((and (has-value? a2) (has-value? sum))
		   (set-value! a1
					   (- (get-value sum) (get-value a2))
					   me))))
  (define (process-forget-value)
	(forget-value! sum me)
	(forget-value! a1 me)
	(forget-value! a2 me)
	(process-new-value))
  (define (me request)
	(cond ((eq? request 'I-have-a-value)
		   (process-new-value))
		  ((eq? request 'I-lost-my-value)
		   (process-forget-value))
		  (else
		   (error "Unknown request -- ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
(define (multiplier m1 m2 product)
  (define (process-new-value)
	(cond ((or (and (has-value? m1) (= (get-value m1) 0))
			   (and (has-value? m2) (= (get-value m2) 0)))
		   (set-value! product 0 me))
		  ((and (has-value? m1) (has-value? m2))
		   (set-value! product
					   (* (get-value m1) (get-value m2))
					   me))
		  ((and (has-value? product) (has-value? m1))
		   (set-value! m2
					   (/ (get-value product) (get-value m1))
					   me))
		  ((and (has-value? product) (has-value? m2))
		   (set-value! m1
					   (/ (get-value product) (get-value m2))
					   me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
(define (constant value connector)
  (define (me request)
	(error "Unknown request -- CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)

(define (probe name connector)
  (define (print-probe value)
	(newline)
	(display "Probe: ")
	(display name)
	(display " = ")
	(display value))
  (define (process-new-value)
	(print-probe (get-value connector)))
  (define (process-forget-value)
	(print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- PROBE" request))))
  (connect connector me)
  me)
;;Representing connectors
(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
	(define (set-my-value newval setter)
	  (cond ((not (has-value? me))
			 (set! value newval)
			 (set! informant setter)
			 (for-each-except setter
							  inform-about-value
							  constraints))
			((not (= value newval))
			 (error "Contradiction" (list value newval)))
			(else 'ignored)))
	(define (forget-my-value retractor)
	  (if (eq? retractor informant)
		  (begin (set! informant false)
				 (for-each-except retractor
								  inform-about-no-value
								  constraints))
		  'ignored))
	(define (connect new-constraint)
	  (if (not (memq new-constraint constraints))
		  (set! constraints
				(cons new-constraint constraints)))
	  (if (has-value? me)
		  (inform-about-value new-constraint))
	  'done)
	(define (me request)
	  (cond ((eq? request 'has-value?)
			 (if informant true false))
			((eq? request 'value) value)
			((eq? request 'set-value!) set-my-value)
			((eq? request 'forget) forget-my-value)
			((eq? request 'connect) connect)
			(else (error "Unknown operation -- CONNECTOR"
						 request))))
	me))
(define (for-each-except exception procedure list)
  (define (loop items)
	(cond ((null? items) 'done)
		  ((eq? (car items) exception) (loop (cdr items)))
		  (else (procedure (car items))
				(loop (cdr items)))))
  (loop list))
(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
(define C (make-connector))
(define F (make-connector))
(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
		(v (make-connector))
		(w (make-connector))
		(x (make-connector))
		(y (make-connector)))
	(multiplier c w u)
	(multiplier v x u)
	(adder v y f)
	(constant 9 w)
	(constant 5 x)
	(constant 32 y)
	'ok))
(celsius-fahrenheit-converter C F)
(probe "Celsius temp" C)
(probe "Fahrenheit temp" F)
(set-value! C 25 'user)
(forget-value! C 'user)
(forget-value! F C)
(set-value! F 212 'user)
(define a (make-connector))
(define b (make-connector))
(define c (make-connector))
(define avg (make-connector))
(define (averager a b c avg)
  (let ((s-ab (make-connector))
		(s-abc (make-connector))
		(div (make-connector)))
	(adder a b s-ab)
	(adder s-ab c s-abc)
	(constant (/ 1 3) div)
	(multiplier s-abc div avg)
	'ok))
(probe "Average" avg)
(averager a b c avg)
(set-value! a 1 'user)
(set-value! b 2 'user)
(set-value! c 3 'user)
(define (squarer a b)
  (define (process-new-value)
	(if (has-value? b)
		(if (< (get-value b) 0)
			(error "square less than 0 -- SQUARER" (get-value b))
			(set-value! a (sqrt (get-value b)) me))
		(if (has-value? a)
			(set-value! b (square (get-value a)) me))))
  (define (process-forget-value)
	(forget-value! a me)
	(forget-value! b me)
	(process-new-value))
  (define (me request)
	(cond ((eq? request 'I-have-a-value)
		   (process-new-value))
		  ((eq? request 'I-lost-my-value)
		   (process-forget-value))
		  (else
		   (error "Unknown request -- Multiplier" request))))
  (connect a me)
  (connect b me)
  me)
(define a (make-connector))
(define b (make-connector))
(squarer a b)
(probe "Root" a)
(probe "Square" b)
(set-value! a 2 'user)
(forget-value! a 'user)
(set-value! b 4 'user)
(forget-value! b 'user)
(define (c+ x y)
  (let ((z (make-connector)))
	(adder x y z)
	z))
(define (c* x y)
  (let ((z (make-connector)))
	(multiplier x y z)
	z))
(define (cv val)
  (let ((z (make-connector)))
	(constant val z)
	z))
(define (unary- a1 a2)
  (define (process-new-value)
	(cond ((has-value? a1)
		   (set-value! a2 (- (get-value a1)) me))
		  ((has-value? a2)
		   (set-value! a1 (- (get-value a2)) me))))
  (define (process-forget-value)
	(forget-value! a1 me)
	(forget-value! a2 me)
	(process-new-value))
  (define (me request)
	(cond ((eq? request 'I-have-a-value)
		   (process-new-value))
		  ((eq? request 'I-lost-my-value)
		   (process-forget-value))
		  (else
		   (error "Unknown request -- ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  me)
(define a (make-connector))
(define b (make-connector))
(unary- a b)
(probe "a" a)
(probe "b" b)
(set-value! a 1 'user)
(forget-value! a 'user)
(define (subtracter a1 a2 result)
  (let ((tmp (make-connector)))
	(unary- a2 tmp)
	(adder a1 tmp result)))
(define a (make-connector))
(define b (make-connector))
(define result (make-connector))
(subtracter a b result)
(probe "result" result)
(set-value! a 1 'user)
(set-value! b 1 'user)
(forget-value! a 'user)
;;3.4 Concurrency: Time Is of the Essence
;; (define (make-account balance)
;;   (define (withdraw amount)
;; 	(if (>= balance amount)
;; 		(begin (set! balance (- balance amount))
;; 			   balance)
;; 		"Insufficient funds"))
;;   (define (deposite amount)
;; 	(set! balance (+ balance amount))
;; 	balance)
;;   (let ((protected (make-serializer)))
;; 	(define (dispatch m)
;; 	  (cond ((eq? m 'withdraw) (protected withdraw))
;; 			((eq? m 'deposit) (protected deposit))
;; 			((eq? m 'balance) balance)
;; 			(else (error "Unknown request -- MAKE-ACCOUNT"
;; 						 m))))
;; 	dispatch))
;; ;;Implementing serializers
;; (define (make-serializer)
;;   (let ((mutex (make-mutex)))
;; 	(lambda (p)
;; 	  (define (seialized-p . args)
;; 		(mutex 'acquire)
;; 		(let ((val (apply p args)))
;; 		  (mutex 'release)
;; 		  val))
;; 	  serialized-p)))
;; (define (make-mutex)
;;   (let ((cell (list false)))
;; 	(define (the-mutex m)
;; 	  (cond ((eq? m 'acquire)
;; 			 (if (test-and-set! cell)
;; 				 (the-mutex 'acquire)))
;; 			((eq? m 'release) (clear! cell))))
;; 	the-mutex))
;; (define (clear! cell)
;;   (set-car! cell false))
;; (define (test-and-set! cell)
;;   (if (car cell)
;; 	  true
;; 	  (begin (set-car! cell true)
;; 			 false)))
;; (define (test-and-clear! cell)
;;   (if (not (car cell))
;; 	  true
;; 	  (begin (set-car! cell false)
;; 			 false)))
;; (define (make-semaphore n)
;;   (let ((own-lock (make-mutex))
;; 		(available n))
;; 	(define (the-semaphore m)
;; 	  (cond ((eq? m 'acquire)
;; 			 (own-lock 'acquire)
;; 			 (if (> available 0)
;; 				 (begin (set! available (- available 1))
;; 						(own-lock 'release))
;; 				 (begin (own-lock 'release)
;; 						(the-semaphore 'acquire))))
;; 			((eq? m 'release)
;; 			 (own-lock 'acquire)
;; 			 (if (< available n)
;; 				 (begin (set! available (+ available 1))
;; 						(own-lock 'release))
;; 				 (own-lock 'release)))))
;; 	the-semaphore))
;; (define (make-semaphore n)
;;   (define (make-n-cells)
;; 	(define (iter n-cells n)
;; 	  (if (= n 0)
;; 		  n-cells
;; 		  (cons (list false) (iter n-cells (- n 1)))))
;; 	(iter '() n))
;;   (define (try-acquire-from-cells cells)
;; 	(define (acquire-loop i)
;; 	  (if (= i (length cells))
;; 		  (acquire-loop 0)
;; 		  (if (test-and-set! (list-ref cells i))
;; 			  (acquire-loop (+ i 1)))))
;; 	(acquire-loop 0))
;;   (define (try-release-from-cells cells)
;; 	(define (clear-loop i)
;; 	  (if (= i (length cells))
;; 		  (clear-loop 0)
;; 		  (if (test-and-clear! (list-ref cells i))
;; 			  (acquire-loop (+ i 1)))))
;; 	(clear-loop 0))
;;   (let ((cells (make-n-cells)))
;; 	(define (the-semaphore m)
;; 	  (cond ((eq? m 'acquire)
;; 			 (try-acquire-from-cells cells))
;; 			((eq? m 'release)
;; 			 (try-release-from-cells cells))))
;; 	the-semaphore))
;; (define (serialized-exchange account1 account2)
;;   (let ((serializer1 (account1 'serializer))
;; 		(serializer2 (account2 'serializer)))
;; 	(if (> (account1 'id) (account2 'id))
;; 		((serializer1 (serializer2 exchange)) account1 account2)
;; 		((serializer2 (serializer1 exchange)) account1 account2))))
;;Concurrency, time, and communication
;;3.5 Streams
;;3.5.1 Streams Are Delayed Lists
(define (stream-ref s n)
  (if (= n 0)
	  (stream-car s)
	  (stream-ref (stream-cdr s) (- n 1))))
(define (stream-map proc . argstreams)
  (if (null? (car argstreams))
	  '()
	  (cons-stream
	   (apply proc (map stream-car argstreams))
	   (apply stream-map
			  (cons proc (map stream-cdr argstreams))))))
(define (stream-for-each proc s)
  (if (null? s)
	  'done
	  (begin (proc (stream-car s))
			 (stream-for-each proc (stream-cdr s)))))
(define (display-stream s)
  (stream-for-each display-line s))
(define (display-line x)
  (newline)
  (display x))
(define (stream-enumerate-interval low high)
  (if (> low high)
	  '()
	  (cons-stream
	   low
	   (stream-enumerate-interval (+ low 1) high))))
(define (stream-filter pred stream)
  (cond ((null? stream) '())
		((pred (stream-car stream))
		 (cons-stream (stream-car stream)
					  (stream-filter pred (stream-cdr stream))))
		(else
		 (stream-filter pred (stream-cdr stream)))))
;;Implementing `delay' and `force'
(define (memo-proc proc)
  (let ((already-run? false) (result false))
	(lambda ()
	  (if (not already-run?)
		  (begin (set! result (proc))
				 (set! already-run? true)
				 result)
		  result))))
;;3.5.2 Infinite Streams
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))
(define integers (integers-starting-from 1))
(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
				 integers))
(define (fibgen a b)
  (cons-stream a
			   (fibgen (+ a b) a)))
(define fibs (fibgen 0 1))
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter (lambda (x)
						   (not (divisible? x (stream-car stream))))
						 (stream-cdr stream)))))
(define primes (sieve (integers-starting-from 2)))
;;Defining streams implicitly
(define ones (cons-stream 1 ones))
(define (add-streams s1 s2)
  (stream-map + s1 s2))
(define integers (cons-stream 1 (add-streams ones integers)))
(define fibs
  (cons-stream 0
			   (cons-stream 1
							(add-streams (stream-cdr fibs)
										 fibs))))
(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))
(define double (cons-stream 1 (scale-stream double 2)))
(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
(define (prime? n)
  (define (iter ps)
	(cond ((> (square (stream-car ps)) n) true)
		  ((divisible? n (stream-car ps)) false)
		  (else (iter (stream-cdr ps)))))
  (iter primes))
(define (mul-streams s1 s2)
  (stream-map * s1 s2))
(define (div-streams s1 s2)
  (stream-map / s1 s2))
(define factorials (cons-stream 1 (mul-streams factorials
											   (integers-starting-from 2))))
(define (partial-sums s)
  (cons-stream (stream-car s)
			   (add-streams (stream-cdr s)
							(partial-sums s))))
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
				((stream-null? s2) s1)
				(else
				 (let ((s1car (stream-car s1))
							 (s2car (stream-car s2)))
					 (cond ((< s1car s2car)
									(cons-stream s1car (merge (stream-cdr s1) s2)))
								 ((> s1car s2car)
									(cons-stream s2car (merge s1 (stream-cdr s2))))
								 (else
									(cons-stream s1car
															 (merge (stream-cdr s1)
																			(stream-cdr s2)))))))))
(define S (cons-stream 1 (merge (merge (scale-stream S 2)
									   (scale-stream S 3))
								(scale-stream S 5))))
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
(define p (div-streams ones (integers-starting-from 1)))
(define (integrate-series s)
  (mul-streams s p))
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
(define sin-series
  (cons-stream 0 (integrate-series cos-series)))
(define cos-series
  (cons-stream 1 (stream-map (lambda (x) (- x))
							 (integrate-series sin-series))))
(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2))
			   (add-streams
				(add-streams
				 (scale-stream (stream-cdr s1) (stream-car s2))
				 (scale-stream (stream-cdr s2) (stream-car s1)))
				(cons-stream 0 (mul-series (stream-cdr s1) (stream-cdr s2))))))
(define (invert-unit-series s)
  (cons-stream 1 (stream-map (lambda (x) (- x))
							 (mul-series (stream-cdr s)
										 (invert-unit-series s)))))
(define (div-series s1 s2)
  (if (= (stream-car s2) 0)
	  (error "Denominator with zero constant term -- DIV-SERIES" s2)
	  (mul-series s1 (invert-unit-series s2))))
(define tan-series (div-series sin-series cos-series))
;;3.5.3 Exploiting the Stream Paradigm
;;Formulating iterations as stream processes
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
(define (average a b) (/ (+ a b) 2))
(define (sqrt-stream x)
  (define guesses
	(cons-stream 1.0
				 (stream-map (lambda (guess)
							   (sqrt-improve guess x))
							 guesses)))
  guesses)
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
			   (stream-map - (pi-summands (+ n 2)))))
(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))
		(s1 (stream-ref s 1))
		(s2 (stream-ref s 2)))
	(cons-stream (- s2 (/ (square (- s2 s1))
						  (+ s0 (* -2 s1) s2)))
				 (euler-transform (stream-cdr s)))))
(define (make-tableau transform s)
  (cons-stream s
			   (make-tableau transform
							 (transform s))))
(define (accelerated-sequence transform s)
  (stream-map stream-car
			  (make-tableau transform s)))
(define (stream-cadr s) (stream-car (stream-cdr s)))
(define (stream-limit s tolerance)
  (let ((s0 (stream-car s))
		(s1 (stream-cadr s)))
	(if (< (abs (- s0 s1)) tolerance)
		s1
		(stream-limit (stream-cdr s) tolerance))))
(define (sqrt-tol x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
(define (ln2-summands n)
  (cons-stream (/ 1.0 n)
			   (stream-map - (ln2-summands (+ n 1)))))
(define ln2-stream
  (partial-sums (ln2-summands 1)))
;;Infinite streams of pairs
(define (interleave s1 s2)
  (if (stream-null? s1)
	  s2
	  (cons-stream (stream-car s1)
				   (interleave s2 (stream-cdr s1)))))
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
	 (interleave
		(stream-map (lambda (x) (list (stream-car s) x))
								(stream-cdr t))
		(pairs (stream-cdr s) (stream-cdr t)))))
(define (triples s t r)
	(cons-stream
	 (list (stream-car s) (stream-car t) (stream-car r))
	 (interleave
		(stream-map (lambda (x) (cons (stream-car s) x))
								(pairs t r))
		(triples (stream-cdr s) (stream-cdr t) (stream-cdr r)))))
(define ptg-triples
	(stream-filter
	 (lambda (x)
		 (let ((a (car x))
					 (b (cadr x))
					 (c (caddr x)))
			 (= (square c)
					(+ (square a) (square b)))))
	 (triples integers integers integers)))
(define (merge-weighted weight s1 s2)
	(cond ((stream-null? s1) s2)
				((stream-null? s2) s1)
				(else
				 (let ((s1car (stream-car s1))
							 (s2car (stream-car s2)))
					 (let ((s1carw (weight s1car))
								 (s2carw (weight s2car)))
						 (cond ((< s1carw s2carw)
										(cons-stream s1car
																 (merge-weighted weight
																								 (stream-cdr s1) s2)))
									 ((> s1carw s2carw)
										(cons-stream s2car
																 (merge-weighted weight
																								 s1 (stream-cdr s2))))
									 (else
										(cons-stream
										 s1car
										 (cons-stream
											s2car
											(merge-weighted weight
																			(stream-cdr s1)
																			(stream-cdr s2)))))))))))
(define (weighted-pairs weight s t)
	(cons-stream
	 (list (stream-car s) (stream-car t))
	 (merge-weighted weight
									 (stream-map (lambda (x) (list (stream-car s) x))
															 (stream-cdr t))
									 (weighted-pairs weight
																	 (stream-cdr s)
																	 (stream-cdr t)))))
(define 235-weighted-pairs
	(stream-filter
	 (lambda (x)
		 (let ((i (car x)) (j (cadr x)))
			 (and (not (= (modulo i 2) 0))
						(not (= (modulo i 3) 0))
						(not (= (modulo i 5) 0))
						(not (= (modulo j 2) 0))
						(not (= (modulo j 3) 0))
						(not (= (modulo j 5) 0)))))
	 (weighted-pairs
		(lambda (x)
			(+ (* 2 (car x))
				 (* 3 (cadr x))
				 (* 5 (car x) (cadr x))))
		integers
		integers)))
(define (ramanujan-nums)
	(define (weight x)
		(+ (* (car x) (car x) (car x))
			 (* (cadr x) (cadr x) (cadr x))))
	(define (search wpairs)
		(let ((first (stream-car wpairs))
					(next (stream-cadr wpairs)))
			(if (= (weight first) (weight next))
					(cons-stream
					 first
					 (cons-stream next
												(search (stream-cdr (stream-cdr wpairs)))))
					(search (stream-cdr wpairs)))))
	(search (weighted-pairs weight integers integers)))
(define (three-ways-squares)
	(define (weight x)
		(+ (square (car x))
			 (square (cadr x))))
	(define (search wpairs)
		(let ((first (stream-car wpairs))
					(second (stream-cadr wpairs))
					(third (stream-car (stream-cdr (stream-cdr wpairs)))))
			(if (= (weight first) (weight second) (weight third))
					(cons-stream
					 first
					 (cons-stream
						second
						(cons-stream
						 third
						 (search
							(stream-cdr (stream-cdr (stream-cdr wpairs)))))))
					(search (stream-cdr wpairs)))))
	(search (weighted-pairs weight integers integers)))
(define (integral integrand initial-value dt)
	(define int
		(cons-stream initial-value
								 (add-streams (scale-stream integrand dt)
															int)))
	int)
(define (RC r c dt)
	(lambda (i v0)
		(add-streams
		 (scale-stream ones v0)
		 (add-streams
			(scale-stream (integral i 0 dt)
										(/ 1 c))
			(scale-stream i r)))))
(define (smooth s)
	(let ((first (stream-car s))
				(next (stream-cadr s)))
		(cons-stream (average first next)
								 (smooth (stream-cdr s)))))
;; 3.5.4 Streams and Delayed Evaluation
(define (integral delayed-integrand initial-value dt)
	(define int
		(cons-stream initial-value
								 (let ((integrand (force delayed-integrand)))
									 (add-streams (scale-stream integrand dt)
																int))))
	int)
(define (solve f y0 dt)
	(define y (integral (delay dy) y0 dt))
	(define dy (stream-map f y))
	y)
(define (solve-2nd a b dt y_0 dy_0)
	(define y (integral (delay dy) y_0 dt))
	(define dy (integral (delay ddy) dy_0 dt))
	(define ddy (add-streams (scale-stream dy a)
													 (scale-stream y b)))
	y)
(define (RLC R L C dt)
	(lambda (v_C0 i_L0)
		(define v_C (integral (delay d_vC) v_C0 dt))
		(define i_L (integral (delay d_iL) i_L0 dt))
		(define d_vC (scale-stream i_L (/ -1 C)))
		(define d_iL
			(add-streams (scale-stream v_C (/ 1 L))
									 (scale-stream i_L (/ -R L))))
		(stream-map cons v_C i_L)))
;; Normal-order evaluation
;; 3.5.5 Modularity of Functional Programs and Modularity of Objects
(define random-init 17)
(define (rand-update x) (remainder (+ (* 13 x) 5) 24))
(define (map-successive-pairs f s)
	(cons-stream
	 (f (stream-car s) (stream-car (stream-cdr s)))
	 (map-successive-pairs f (stream-cdr (stream-cdr s)))))
(define cesaro-stream
	(map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))
												random-numbers))
(define (monte-carlo experiment-stream passed failed)
	(define (next passed failed)
		(cons-stream
		 (/ passed (+ passed failed))
		 (monte-carlo
			(stream-cdr experiment-stream) passed failed)))
	(if (stream-car experiment-stream)
			(next (+ passed 1) failed)
			(next passed (+ failed 1))))
(define pi
	(stream-map (lambda (p) (sqrt (/ 6 p)))
							(monte-carlo cesaro-stream 0 0)))
(define (random-in-range low high)
	(cons-stream
	 (+ low (random (- high low)))
	(stream-map
	 (lambda (r)
		 (+ low (random (- high low))))
	 integers)))
(define (random-in-range-scaled low high scale-factor)
	(stream-map
	 (lambda (r)
		 (/ r scale-factor))
	 (random-in-range (* low scale-factor) (* high scale-factor))))
(define (estimate-integral p x1 x2 y1 y2)
  (define (experiment-stream)
		(define (iter x-stream y-stream)
			(cons-stream (p (stream-car x-stream)
											(stream-car y-stream))
									 (iter (stream-cdr x-stream) =
												 (stream-cdr y-stream))))
			(iter (random-in-range-scaled x1 x2 1000)
			      (random-in-range-scaled y1 y2 1000)))
	(define (iter mc-results)
		(cons-stream (* (stream-car mc-results) (rec-area x1 x2 y1 y2))
								 (iter (stream-cdr mc-results))))
	(iter (monte-carlo (experiment-stream) 0 0)))
(define (p x y)
	(le (+ (square x)
				 (square y))
			1))
(define pi-stream (* (estimate-integral p 0 2 0 2) 4))
;; A functional-programming view of time
