;; Chapter 4: Metalinguistic Abstraction
;; 4.1 The Metacircular Evaluator
;; 4.1.1 The Core of the Evaluator
;; Eval
;; (define (eval exp env)
;;  (cond ((self-evaluating? exp) exp)
;;        ((variable? exp) (lookup-variable-value exp env))
;;        ((quoted? exp) (text-of-quotation exp))
;;        ((assignment? exp) (eval-assignment exp env))
;;        ((definition? exp) (eval-definition exp env))
;;        ((if? exp) (eval-if exp env))
;;        ((lambda? exp)
;;         (make-procedure (lambda-parameters exp)
;;                         (lambda-body exp)
;;                         env))
;;        ((begin? exp)
;;         (eval-sequence (begin-actions exp) env))
;;        ((cond? exp) (eval (cond->if exp) env))
;;        ((and? exp) (eval (and->if exp) env))
;;        ((or? exp) (eval (or->if exp) env))
;;        ((let? exp) (eval (let->combination exp) env))
;;        ((let*? exp) (eval (let*->nested-lets exp) env))
;;        ((letrec? exp) (eval (scan-out-letrec exp) env))
;;        ((unbind? exp) (eval-unbind exp env)) ; DOES NOT WORK
;;        ((application? exp)
;;         (meta-apply (eval (operator exp) env)
;;                     (list-of-values (operands exp) env)))
;;        (else
;;         (error "Unknown expression type -- EVAL" exp))))
;; Apply
(define (meta-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))
;; Procedure arguments
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
;; Conditionals
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
;; Sequences
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
;; Assignments and definitions
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  (assignment-variable exp))
(define (eval-definition exp env)
  (define-variable!
    (definition-variable exp)
    (eval (definition-value exp) env)
    env)
  (definition-variable exp))
;; Exercise 4.1
(define (list-of-values-l2r exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-exp exps) env)))
        (cons first (list-of-values-l2r (rest-exps exps) env)))))
(define (list-of-values-r2l exps env)
  (if (no-operands exps)
      '()
      (let ((first (list-of-values-r2l (rest-exps exps) env)))
        (cons (eval (first-exp exps) env) first))))
;; Representing Expressions
;; Self-evaluating
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
;; Variable
(define (variable? exp) (symbol? exp))
;; Quoted
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
;; Assignment
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
;; Definition
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))
(define (make-procedure-definition name vars body)
  (append (list 'define (append (list name) vars)) body))
;; Lambda
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-lambda parameters body)
  (append (list 'lambda parameters) body))
;; Conditionals
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
;; Begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
;; Application
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
;; Cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (cond-test-recipient-clause? clause)
  (eq? (cadr clause) '=>))
(define (cond-recipient clause) (caddr clause))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (cond ((cond-else-clause? first)
               (if (null? rest)
                   (sequence->exp (cond-actions first))
                   (error "ELSE clause isn't last -- COND->IF"
                          clauses)))
              ((cond-test-recipient-clause? first)
               (make-if (cond-predicate clause)
                        ((cond-recipient clause) (cond-predicate clause))
                        (expand-clauses rest)))
              (else (make-if (cond-predicate first)
                             (sequence->exp (cond-actions first))
                             (expand-clauses rest)))))))
;; And & Or
(define (and? exp) (tagged-list? exp 'and))
(define (and-predicates exp) (cdr exp))
(define (and->if exp)
  (expand-and-predicates (and-predicates exp)))
(define (expand-and-predicates preds)
  (if (null? preds)
      'true
      (let ((first (car preds))
            (rest (cdr preds)))
        (make-if first (expand-and-predicates rest) 'false))))
(define (or? exp) (tagged-list? exp 'or))
(define (or-predicates exp) (cdr exp))
(define (or->if exp)
  (expand-or-predicates (or-predicates exp)))
(define (expand-or-predicates preds)
  (if (null? preds)
      'false
      (let ((first (car preds))
            (rest (cdr preds)))
        (make-if first 'true (expand-or-predicates rest)))))

;; Let
(define (let? exp) (tagged-list? exp 'let))
(define (let-assignment-clauses exp) (cadr exp))
(define (let-assignment-variables assignments)
  (map car assignments))
(define (let-assignment-values assignments)
  (map cadr assignments))
(define (let-body exp) (cddr exp))
(define (let->combination exp)
  (if (not (named-let? exp))
      (let ((assignment-clauses (let-assignment-clauses exp)))
        (append
         (list (make-lambda (let-assignment-variables assignment-clauses)
                            (let-body exp)))
         (let-assignment-values assignment-clauses)))
      ;; Named let
      (let ((assignment-clauses (named-let-assignment-clauses exp)))
        (sequence->exp
         (list
          (make-procedure-definition
           (named-let-var exp)
           (let-assignment-variables assignment-clauses)
           (named-let-body exp))
          (append (list (named-let-var exp))
                  (let-assignment-values assignment-clauses)))))
      ))
(define (make-let assignment-clauses body)
  (append (list 'let assignment-clauses) body))
;; Let*
(define (let*? exp) (tagged-list? exp 'let*))
(define (let*->nested-lets exp)
  (define (loop assignment-clauses)
    (if (null? assignment-clauses)
        (let-body exp)
        (if (null? (cdr assignment-clauses))
            (make-let (list (car assignment-clauses))
                      (loop (cdr assignment-clauses)))
            (make-let (list (car assignment-clauses))
                      (list (loop (cdr assignment-clauses)))))))
  (loop (let-assignment-clauses exp)))
;; Named let
(define (named-let? exp)
  (symbol? (cadr exp)))
(define (named-let-var exp) (cadr exp))
(define (named-let-assignment-clauses exp) (caddr exp))
(define (named-let-body exp) (cdddr exp))
;; For loop
;; Syntax: (for <init-bindings> <predicate> <advance> <body>)
(define (for? exp) (tagged-list? exp 'for))
(define non-exec-retval '())
(define (for-bindings exp) (cadr exp))
(define (for-predicate exp) (caddr exp))
(define (for-advance exp) (cadddr exp))
(define (for-body exp) (car (cddddr exp)))
(define (for->combination exp)
  (make-let
   (for-bindings exp)
   (sequence->exp
    (list
     (make-procedure-definition
      'loop
      '(retval)
      (make-if
       (for-predicate exp)
       (make-let (list (list 'retval (for-body exp)))
                 (sequence->exp (list (for-advance exp) (list 'loop 'retval))))
       'retval))
     (list 'loop ''())))))
;; 4.1.3 Evaluator Data Structures
;; Testing of predicates
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))
;; Representing procedures
(define (make-procedure parameters body env)
  (if (null? (definition-expressions body))
      (list 'procedure parameters body env)
      (list 'procedure parameters (list (scan-out-defines body)) env)))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
;; Operations on Environments
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
;; (define (lookup-variable-value var env)
;;  (define (env-loop env)
;;    (define (scan vars vals)
;;      (cond ((null? vars)
;;             (env-loop (enclosing-environment env)))
;;            ((eq? var (car vars))
;;             (car vals))
;;            (else (scan (cdr vars) (cdr vals)))))
;;    (if (eq? env the-empty-environment)
;;        (error "Unbound variable" var)
;;        (let ((frame (first-frame env)))
;;          (scan (frame-variables frame)
;;                (frame-values frame)))))
;;  (env-loop env))
;; (define (lookup-variable-value var env)
;;  (define (env-loop env)
;;    (define (scan vars vals)
;;      (cond ((null? vars)
;;             (env-loop (enclosing-environment env)))
;;            ((eq? var (car vars))
;;             (car vals))
;;            (else (scan (cdr vars) (cdr vals)))))
;;    (if (eq? env the-empty-environment)
;;        (error "Unbound variable" var)
;;        (let ((frame (first-frame env)))
;;          (scan (frame-variables frame)
;;                (frame-values frame)))))
;;  (env-loop env))
;; (define (set-variable-value! var val env)
;;  (define (env-loop env)
;;    (define (scan vars vals)
;;      (cond ((null? vars)
;;             (env-loop (enclosing-environment env)))
;;            ((eq? var (car vars))
;;             (set-car! vals val))
;;            (else (scan (cdr vars) (cdr vals)))))
;;    (if (eq? env the-empty-environment)
;;        (error "Unbound variable" var)
;;        (let ((frame (first-frame env)))
;;          (scan (frame-variables frame)
;;                (frame-values frame)))))
;;  (env-loop env))
;; (define (define-variable! var val env)
;;  (let ((frame (first-frame env)))
;;    (define (scan vars vals)
;;      (cond ((null? vars)
;;             (add-binding-to-frame! var val frame))
;;            ((eq? var (car vars))
;;             (set-car! vals val))
;;            (else (scan (cdr vars) (cdr vals)))))
;;    (scan (frame-variables frame)
;;          (frame-values frame))))
(define (scan-var-frame var vars vals not-found-proc found-proc)
  (cond ((null? vars)
         (not-found-proc))
        ((eq? var (car vars))
         (found-proc vars vals))
        (else (scan-var-frame var (cdr vars) (cdr vals)
                              not-found-proc found-proc))))
(define (scan-var-env var env found-proc)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan-var-frame var
                          (frame-variables frame)
                          (frame-values frame)
                          (lambda () (env-loop (enclosing-environment env)))
                          found-proc))))
  (env-loop env))
(define (lookup-variable-value var env)
  (scan-var-env
   var env
   (lambda (vars vals)
     (if (eq? (car vals) '*unassigned*)
         (error "Unassigned variable" (car vars))
         (car vals)))))
(define (set-variable-value! var val env)
  (scan-var-env var env
                (lambda (vars vals) (set-car! vals val))))
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (scan-var-frame var
                    (frame-variables frame)
                    (frame-values frame)
                    (lambda () (add-binding-to-frame! var val frame))
                    (lambda (vars vals) (set-car! vals val)))))
;; make-unbound!
(define (unbind? exp) (tagged-list? exp 'unbind!))
(define (unbind-variable exp) (cadr exp))
(define (eval-unbind exp env)
  ())
(define (make-unbound! var env)
  (let ((frame (first-frame env)))
    (scan-var-frame var
                    (frame-variables frame)
                    (frame-values frame)
                    (lambda () (error "Unbound variable" var))
                    (lambda (pvars pvals)
                      (set-cdr! pvars (cdr (cdr pvars)))
                      (set-cdr! pvals (cdr (cdr pvals)))))))
;; 4.1.4 Running the Evaluator as a Program
;; Primitives
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define (primitive-procedure? proc) (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        (list '< <)
        (list '> >)
        (list '= =)
        (list 'display display)
        (list 'square square)
        (list 'not not)
        (list 'list list)
        (list 'even? even?)
        (list 'member member)
        (list 'abs abs)
        ))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
(define (apply-primitive-procedure proc args)
  (apply (primitive-implementation proc) args))
;; Driver loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read))
        (start-time (runtime)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output start-time)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))
(define (user-print object start-time)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (begin
        (display object)
        (newline)
        (display "Run time: ")
        (display (- (runtime) start-time)))))
(define the-global-environment (setup-environment))
;; 4.1.5 Data as Programs
;; 4.1.6 Internal Definitions
(define (scan-out-defines body)
  (let* ((def-expressions (definition-expressions body))
         (def-variables (definition-variables def-expressions))
         (def-values (definition-values def-expressions)))
    (make-let
     (map (lambda (var) (list var ''*unassigned*)) def-variables)
     (append
      (map (lambda (var val) (list 'set! var val))
           def-variables
           def-values)
      (non-definition-expressions body)))))
(define (definition-expressions body)
  (scan-expressions body (lambda (exp) (tagged-list? exp 'define))))
(define (non-definition-expressions body)
  (scan-expressions body (lambda (exp) (not (tagged-list? exp 'define)))))
(define (scan-expressions body predicate)
  (cond ((null? body) '())
        ((predicate (car body))
         (cons (car body) (scan-expressions (cdr body) predicate)))
        (else (scan-expressions (cdr body) predicate))))
(define (definition-values def-expressions)
  (map definition-value def-expressions))
(define (definition-variables def-expressions)
  (map definition-variable def-expressions))
;; Exercise 4.19
;; (define (parallel-define def-expressions env)
;;  (let ((vars (definition-variables def-expressions))
;;        (vals (definition-values def-expressions)))
;;    (define (eval-all-loop vars vals
;;                           defined-vars defined-vals
;;                           try-eval-env in-enclosing-env)
;;      (define (try-eval-loop vars vals
;;                             undefined-vars undefined-vals
;;                             defined-vars defined-vals
;;                             try-eval-env)
;;        (cond ((null? vars)
;;               (list undefined-vars undefined-vals
;;                     defined-vars defined-vals))
;;              ((eval-success (car vals) try-eval-env)
;;               (let ((eval-result (eval (car vals) try-eval-env)))
;;                 (if (memq (car vars) defined-vars)
;;                     (error "Multiple parallel definitions of same variable"
;;                            (car vars))
;;                     (try-eval-loop (cdr vars) (cdr vals)
;;                                    undefined-vars undefined-vals
;;                                    (cons (car vars) defined-vars)
;;                                    (cons eval-result defined-vals)
;;                                    (extend-environment
;;                                     (list (car vars))
;;                                     (list eval-result)
;;                                     try-eval-env)))))
;;              (else (try-eval-loop (cdr vars)
;;                                   (cdr vals)
;;                                   (cons (car vars) undefined-vars)
;;                                   (cons (car vals) undefined-vals)
;;                                   defined-vars defined-vals try-eval-env))))
;;      (let* ((try-eval-retval (try-eval-loop vars vals
;;                                             '() '() '() '()
;;                                             try-eval-env))
;;             (undefined-vars (car try-eval-retval))
;;             (undefined-vals (cadr try-eval-retval))
;;             (new-defined-vars (caddr try-eval-retval))
;;             (new-defined-vals (cadddr try-eval-retval))
;;             (all-defined-vars (append new-defined-vars defined-vars))
;;             (all-defined-vals (append new-defined-vals defined-vals))
;;             (num-defined (- (length vars) (length undefined-vars))))
;;        (cond ((null? undefined-vars)
;;               (extend-environment
;;                all-defined-vars
;;                all-defined-vals
;;                env))
;;              ((and (= num-defined 0) in-enclosing-env)
;;               (error "Failed or cyclical definitions"
;;                      undefined-vars undefined-vals))
;;              ((and (= num-defined 0) (not in-enclosing-env))
;;               (eval-all-loop undefined-vars undefined-vals
;;                              all-defined-vars
;;                              all-defined-vals
;;                              (extend-environment
;;                               all-defined-vars all-defined-vals
;;                               env)
;;                              true))
;;              (else
;;               (eval-all-loop undefined-vars undefined-vals
;;                              all-defined-vars
;;                              all-defined-vals
;;                              (extend-environment
;;                               all-defined-vars all-defined-vals
;;                               try-eval-env)
;;                              in-enclosing-env)))))
;;    (eval-all-loop vars vals '() '() the-empty-environment false)))
;; (define (eval-success exp env)
;;  (define (try)
;;    (eval exp env))
;;  (if (condition? (ignore-errors try))
;;      false
;;      true))
;; (define (meta-apply procedure arguments)
;;  (cond ((primitive-procedure? procedure)
;;         (apply-primitive-procedure procedure arguments))
;;        ((compound-procedure? procedure)
;;         (let ((body (procedure-body procedure))
;;               (env-parameters (extend-environment
;;                                (procedure-parameters procedure)
;;                                arguments
;;                                (procedure-environment procedure))))
;;           (eval-sequence
;;            body
;;            (if (null? (definition-expressions body))
;;                env-parameters
;;                (parallel-define (definition-expressions body)
;;                                 env-parameters)))))
;;        (else
;;         (error "Unknown procedure type -- APPLY" procedure))))
;; (define (make-procedure parameters body env)
;;  (list 'procedure parameters body env))

;; letrec
(define (letrec? exp) (tagged-list? exp 'letrec))
(define (scan-out-letrec exp)
  (let* ((bindings (let-assignment-clauses exp))
         (variables (let-assignment-variables bindings))
         (values (let-assignment-values bindings)))
    (make-let
     (map (lambda (var) (list var ''*unassigned*)) variables)
     (append
      (map (lambda (var val) (list 'set! var val))
           variables values)
      (let-body exp)))))
;; 4.1.7 Separating Syntactic Analysis from Execution
;; (define (eval-analyze exp env)
;;  ((analyze exp) env))
;; (define (analyze exp)
;;  (cond ((self-evaluating? exp)
;;         (analyze-self-evaluating exp))
;;        ((quoted? exp) (analyze-quoted exp))
;;        ((variable? exp) (analyze-variable exp))
;;         ((assignment? exp) (analyze-assignment exp))
;;         ((definition? exp) (analyze-definition exp))
;;         ((if? exp) (analyze-if exp))
;;         ((lambda? exp) (analyze-lambda exp))
;;        ((let? exp) (analyze (let->combination exp)))
;;         ((begin? exp) (analyze-sequence (begin-actions exp)))
;;         ((cond? exp) (analyze (cond->if exp)))
;;         ((application? exp) (analyze-application exp))
;;         (else
;;          (error "Unknown expression type -- ANALYZE" exp))))
;; (define (analyze-self-evaluating exp)
;;  (lambda (env) exp))
;; (define (analyze-quoted exp)
;;  (let ((qval (text-of-quotation exp)))
;;    (lambda (env) qval)))
;; (define (analyze-variable exp)
;;  (lambda (env) (lookup-variable-value exp env)))
;; (define (analyze-assignment exp)
;;  (let ((var (assignment-variable exp))
;;        (vproc (analyze (assignment-value exp))))
;;    (lambda (env)
;;      (set-variable-value! var (vproc env) env)
;;      var)))
;; (define (analyze-definition exp)
;;  (let ((var (definition-variable exp))
;;        (vproc (analyze (definition-value exp))))
;;    (lambda (env)
;;      (define-variable! var (vproc env) env)
;;      var)))
;; (define (analyze-if exp)
;;  (let ((pproc (analyze (if-predicate exp)))
;;        (cproc (analyze (if-consequent exp)))
;;        (aproc (analyze (if-alternative exp))))
;;    (lambda (env)
;;      (if (true? (pproc env))
;;          (cproc env)
;;          (aproc env)))))
;; (define (analyze-lambda exp)
;;  (let ((vars (lambda-parameters exp))
;;        (bproc (analyze-sequence (lambda-body exp))))
;;    (lambda (env) (make-procedure vars bproc env))))
;; (define (analyze-sequence exps)
;;  (define (sequentially proc1 proc2)
;;    (lambda (env) (proc1 env) (proc2 env)))
;;  (define (loop first-proc rest-procs)
;;    (if (null? rest-procs)
;;        first-proc
;;        (loop (sequentially first-proc (car rest-procs))
;;              (cdr rest-procs))))
;;  (let ((procs (map analyze exps)))
;;    (if (null? procs)
;;        (error "Empty sequence -- ANALYZE"))
;;    (loop (car procs) (cdr procs))))
;; (define (analyze-application exp)
;;  (let ((fproc (analyze (operator exp)))
;;        (aprocs (map analyze (operands exp))))
;;    (lambda (env)
;;      (execute-application (fproc env)
;;                           (map (lambda (aproc) (aproc env))
;;                                aprocs)))))
;; (define (execute-application proc args)
;;  (cond ((primitive-procedure? proc)
;;         (apply-primitive-procedure proc args))
;;        ((compound-procedure? proc)
;;         ((procedure-body proc)
;;          (extend-environment (procedure-parameters proc)
;;                              args
;;                              (procedure-environment proc))))
;;        (else
;;         (error
;;          "Unknown procedure type -- EXECUTE-APPLICATION"
;;          proc))))
;; (define (driver-loop-analyze)
;;  (prompt-for-input input-prompt)
;;  (let ((input (read))
;;        (start-time (runtime)))
;;    (let ((output (eval-analyze input the-global-environment)))
;;      (announce-output output-prompt)
;;      (user-print output start-time)))
;;  (driver-loop-analyze))
;; (define (make-procedure parameters body env)
;;  (list 'procedure parameters body env))
;; 4.2 Variations on Scheme - Lazy Evaluation
;; 4.2.1 Normal Order and Applicative Order
;; 4.2.2 An Interpreter with Lazy Evaluation
;; Modifying the evaluator
;; (define (eval exp env)
;;  (cond ((self-evaluating? exp) exp)
;;        ((variable? exp) (lookup-variable-value exp env))
;;        ((quoted? exp) (text-of-quotation exp))
;;        ((assignment? exp) (eval-assignment exp env))
;;        ((definition? exp) (eval-definition exp env))
;;        ((if? exp) (eval-if exp env))
;;        ((lambda? exp)
;;         (make-procedure (lambda-parameters exp)
;;                         (lambda-body exp)
;;                         env))
;;        ((begin? exp)
;;         (eval-sequence (begin-actions exp) env))
;;        ((cond? exp) (eval (cond->if exp) env))
;;        ((and? exp) (eval (and->if exp) env))
;;        ((or? exp) (eval (or->if exp) env))
;;        ((let? exp) (eval (let->combination exp) env))
;;        ((let*? exp) (eval (let*->nested-lets exp) env))
;;        ((letrec? exp) (eval (scan-out-letrec exp) env))
;;        ((unbind? exp) (eval-unbind exp env)) ; DOES NOT WORK
;;        ((application? exp)
;;         (meta-apply (actual-value (operator exp) env)
;;                     (operands exp)
;;                     env))
;;        (else
;;         (error "Unknown expression type -- EVAL" exp))))
;; (define (actual-value exp env)
;;  (force-it (eval exp env)))
;; (define (meta-apply procedure arguments env)
;;  (cond ((primitive-procedure? procedure)
;;         (apply-primitive-procedure
;;          procedure
;;          (list-of-arg-values arguments env)))
;;        ((compound-procedure? procedure)
;;         (eval-sequence
;;          (procedure-body procedure)
;;          (extend-environment
;;           (procedure-parameters procedure)
;;           (list-of-delayed-args arguments env)
;;           (procedure-environment procedure))))
;;        (else
;;         (error
;;          "Unknown procedure type -- APPLY" procedure))))
;; (define (list-of-arg-values exps env)
;;  (if (no-operands? exps)
;;      '()
;;      (cons (actual-value (first-operand exps) env)
;;            (list-of-arg-values (rest-operands exps)
;;                                env))))
;; (define (list-of-delayed-args exps env)
;;  (if (no-operands? exps)
;;      '()
;;      (cons (delay-it (first-operand exps) env)
;;            (list-of-delayed-args (rest-operands exps)
;;                                  env))))
;; (define (eval-if exp env)
;;  (if (true? (actual-value (if-predicate exp) env))
;;      (eval (if-consequent exp) env)
;;      (eval (if-alternative exp) env)))
;; (define input-prompt-lazy ";;; L-Eval input:")
;; (define output-prompt-lazy ";;; L-Eval value:")
;; (define (driver-loop-lazy)
;;   (prompt-for-input input-prompt-lazy)
;;   (let ((input (read)))
;;     (let ((output
;;            (actual-value input the-global-environment)))
;;       (announce-output output-prompt-lazy)
;;       (user-print output (runtime))))
;;   (driver-loop-lazy))
;; Representing thunks
;; (define (force-it obj)
;;  (cond ((thunk? obj)
;;         (let ((result (actual-value
;;                        (thunk-exp obj)
;;                        (thunk-env obj))))
;;           (set-car! obj 'evaluated-thunk)
;;           (set-car! (cdr obj) result)
;;           (set-cdr! (cdr obj) '())
;;           result))
;;        ((evaluated-thunk? obj)
;;         (thunk-value obj))
;;        (else obj)))
;; (define (delay-it exp env)
;;  (list 'thunk exp env))
;; (define (thunk? obj)
;;  (tagged-list? obj 'thunk))
;; (define (thunk-exp thunk) (cadr thunk))
;; (define (thunk-env thunk) (caddr thunk))
;; (define (evaluated-thunk? obj)
;;  (tagged-list? obj 'evaluated-thunk))
;; (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
;; Exercise 4.31
;; (define (meta-apply procedure arguments env)
;;  (cond ((primitive-procedure? procedure)
;;         (apply-primitive-procedure
;;          procedure
;;          (list-of-arg-values arguments env)))
;;        ((compound-procedure? procedure)
;;         (eval-sequence
;;          (procedure-body procedure)
;;          (extend-environment
;;           (decided-pars (procedure-parameters procedure))
;;           (decided-args (procedure-parameters procedure) arguments env)
;;           (procedure-environment procedure))))
;;        (else
;;         (error
;;          "Unknown procedure type -- APPLY" procedure))))
;; (define (decided-pars parameters)
;;  (map (lambda (p)
;;         (if (pair? p)
;;             (car p)
;;             p))
;;       parameters))
;; (define (decided-args parameters arguments env)
;;  (cond ((null? arguments)
;;         '())
;;        ((pair? (car parameters))
;;         (cons (decided-lazy-arg (car parameters) (car arguments) env)
;;               (decided-args (cdr parameters) (cdr arguments) env)))
;;        (else
;;         (cons (actual-value (car arguments) env)
;;               (decided-args (cdr parameters) (cdr arguments) env)))))
;; (define (decided-lazy-arg parameter argument env)
;;  (let ((lazy-mode (cadr parameter)))
;;    (cond ((eq? lazy-mode 'lazy)
;;           (newline)
;;           (display "delay-nomemo ")
;;           (display argument)
;;           (delay-it-nomemo argument env))
;;          ((eq? lazy-mode 'lazy-memo)
;;           (newline)
;;           (display "delay-memo ")
;;           (display argument)
;;           (delay-it argument env))
;;          (else
;;           (error "Unknown evaluation mode -- DECIDED-LAZY-ARG"
;;                  (list (car parameter) lazy-mode))))))
;; (define (delay-it-nomemo exp env)
;;  (list 'thunk-nomemo exp env))
;; (define (force-it obj)
;;  (cond ((thunk? obj)
;;         (let ((result (actual-value
;;                        (thunk-exp obj)
;;                        (thunk-env obj))))
;;           (set-car! obj 'evaluated-thunk)
;;           (set-car! (cdr obj) result)
;;           (set-cdr! (cdr obj) '())
;;           result))
;;        ((evaluated-thunk? obj)
;;         (thunk-value obj))
;;        ((nomemo-thunk? obj)
;;         (actual-value (thunk-exp obj) (thunk-env obj)))
;;        (else obj)))
;; (define (nomemo-thunk? obj)
;;  (tagged-list? obj 'thunk-nomemo))
;; 4.2.3 Streams as Lazy Lists
;; Running in L-Eval
;; (define (cons x y)
;;  (lambda (m) (m x y)))
;; (define (car z)
;;  (z (lambda (p q) p)))
;; (define (cdr z)
;;  (z (lambda (p q) q)))
;; (define (list-ref items n)
;;  (if (= n 0)
;;      (car items)
;;      (list-ref (cdr items) (- n 1))))
;; (define (map proc items)
;;   (if (null? items)
;;       '()
;;       (cons (proc (car items))
;;             (map proc (cdr items)))))
;; (define (scale-list items factor)
;;  (map (lambda (x) (* x factor))
;;       items))
;; (define (add-lists list1 list2)
;;  (cond ((null? list1) list2)
;;        ((null? list2) list1)
;;        (else (cons (+ (car list1) (car list2))
;;                    (add-lists (cdr list1) (cdr list2))))))
;; (define ones (cons 1 ones))
;; (define integers (cons 1 (add-lists ones integers)))
;; (define (integral integrand initial-value dt)
;;  (define int
;;    (cons initial-value
;;          (add-lists (scale-list integrand dt)
;;                     int)))
;;  int)
;; (define (solve f y0 dt)
;;  (define y (integral dy y0 dt))
;;  (define dy (map f y))
;;  y)
;; Exercise 4.33
;; (define (eval exp env)
;;  (cond ((self-evaluating? exp) exp)
;;        ((variable? exp) (lookup-variable-value exp env))
;;        ((quoted? exp) (quoted->combination exp env))
;;        ((assignment? exp) (eval-assignment exp env))
;;        ((definition? exp) (eval-definition exp env))
;;        ((if? exp) (eval-if exp env))
;;        ((lambda? exp)
;;         (make-procedure (lambda-parameters exp)
;;                         (lambda-body exp)
;;                         env))
;;        ((begin? exp)
;;         (eval-sequence (begin-actions exp) env))
;;        ((cond? exp) (eval (cond->if exp) env))
;;        ((and? exp) (eval (and->if exp) env))
;;        ((or? exp) (eval (or->if exp) env))
;;        ((let? exp) (eval (let->combination exp) env))
;;        ((let*? exp) (eval (let*->nested-lets exp) env))
;;        ((letrec? exp) (eval (scan-out-letrec exp) env))
;;        ((unbind? exp) (eval-unbind exp env)) ; DOES NOT WORK
;;        ((application? exp)
;;         (meta-apply (actual-value (operator exp) env)
;;                     (operands exp)
;;                     env))
;;        (else
;;         (error "Unknown expression type -- EVAL" exp))))
;; (define (quoted->combination exp env)
;;  (if (pair? (cadr exp))
;;      (eval (car (make-lazy-list (cadr exp))) env)))
;; (define (make-lazy-list lst)
;;  (if (null? lst)
;;      '('())
;;      (list (append '(cons) (list (car lst)) (make-lazy-list (cdr lst))))))
;; Exercise 4.34
;; 4.3 Variations on a Scheme - Nondeterministic Computing
;; 4.3.1 Amb and Search
;; (define (an-element-of items)
;;  (require (not (null? items)))
;;  (amb (car items) (an-element-of (cdr items))))
;; (define (an-integer-starting-from n)
;;  (amb n (an-integer-starting-from (+ n 1))))
;; Driver loop
;; Exercise 4.35
;; (define (an-integer-between low high)
;;  (require (<= low high))
;;  (amb low (an-integer-between (+ low 1) high)))
;; (define (a-pythagorean-triple-between low high)
;;  (let* ((i (an-integer-between low high))
;;         (j (an-integer-between i high))
;;         (k (an-integer-between j high)))
;;    (require (= (+ (square i) (square j)) (square k)))
;;    (list i j k)))
;; Exercise 4.36
;; Because of non-interleaving, i and j will stay the same while `amb'
;; continues to increase k forever.
;; (define (a-pythagorean-triple-from low)
;;  (let* ((k (an-integer-starting-from low))
;;         (i (an-integer-between low k))
;;         (j (an-integer-between i k)))
;;    (require (= (+ (square i) (square j)) (square k)))
;;    (list i j k)))
;; 4.3.2 Examples of Nondeterministic Programs
;; Logic Puzzles
(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
;; (define (multiple-dwelling)
;;  (let ((baker (amb 1 2 3 4 5))
;;        (cooper (amb 1 2 3 4 5))
;;        (fletcher (amb 1 2 3 4 5))
;;        (miller (amb 1 2 3 4 5))
;;        (smith (amb 1 2 3 4 5)))
;;    (require
;;     distinct? (list baker cooper fletcher miller smith))
;;    (require (not (= baker 5)))
;;    (require (not (= cooper 1)))
;;    (require (not (= fletcher 5)))
;;    (require (not (= fletcher 1)))
;;    (require (> miller cooper))
;;    (require (not (= (abs (- smith fletcher)) 1)))
;;    (require (not (= (abs (- fletcher cooper)) 1)))
;;    (list (list 'baker baker)
;;          (list 'cooper cooper)
;;          (list 'fletcher fletcher)
;;          (list 'miller miller)
;;          (list 'smith smith))))
;; Exercise 4.38
;; Exercise 4.39
;; Exercise 4.40
;; Exercise 4.41
(define (solve-logic-puzzle solution-domain satisfied?)
  (define (loop possible-solutions solutions)
    (cond ((null? possible-solutions) solutions)
          ((apply satisfied? (car possible-solutions))
           (loop (cdr possible-solutions)
                 (cons (car possible-solutions) solutions)))
          (else (loop (cdr possible-solutions) solutions))))
  (loop (enumerate-solutions solution-domain) '()))
(define (enumerate-solutions solution-domain)
  (if (null? solution-domain)
      '(())
      (unest-lists
       (map (lambda (sol)
              (map (lambda (elem) (cons elem sol))
                   (car solution-domain)))
            (enumerate-solutions (cdr solution-domain))))))
(define (unest-lists lst)
  (cond ((null? lst) '())
        ((not (pair? (car (car lst))))
         (cons (car lst) (unest-lists (cdr lst))))
        (else (append (unest-lists (car lst))
                      (unest-lists (cdr lst))))))
;; Exercise 4.42
;; Exercise 4.43
;; Exercise 4.44
(define (queens-r q1 q2 q3 q4 q5)
  (and (check-rows (list q1 q2 q3 q4 q5))
       (check-diag (list q1 q2 q3 q4 q5))))
(define (check-rows queens)
  (distinct? queens))
(define (check-diag queens)
  (define (inner-loop this-queen rest-queens delta)
    (cond ((null? rest-queens) true)
          ((or (= this-queen (+ (car rest-queens) delta))
               (= this-queen (- (car rest-queens) delta)))
           false)
          (else (inner-loop this-queen (cdr rest-queens) (+ delta 1)))))
  (define (outer-loop queens)
    (cond ((null? queens) true)
          ((inner-loop (car queens) (cdr queens) 1)
           (outer-loop (cdr queens)))
          (else false)))
  (outer-loop queens))
;; Parsing natural language
;; (define nouns '(noun student professor cat class))
;; (define verbs '(verb studies lectures eats sleeps))
;; (define articles '(article the a))
;; (define (parse-sentence)
;;  (list 'sentence
;;        (parse-noun-phrase)
;;        (parse-word verbs)))
;; (define (parse-noun-phrase)
;;  (list 'noun-phrase
;;        (parse-word articles)
;;        (parse-word nouns)))
;; (define (parse-word word-list)
;;  (require (not (null? *unparsed*)))
;;  (require (memq (car *unparsed*) (cdr word-list)))
;;  (let ((found-word (car *unparsed*)))
;;    (set! *unparsed* (cdr *unparsed*))
;;    (list (car word-list) found-word)))
;; (define *unparsed* '())
;; (define (parse input)
;;  (set! *unparsed* input)
;;  (let ((sent (parse-sentence)))
;;    (require (null? *unparsed*))
;;    sent))
;; (define prepositions '(prep for to in by with))
;; (define (parse-prepositional-phrase)
;;  (list 'prep-phrase
;;        (parse-word prepositions)
;;        (parse-noun-phrase)))
;; (define (parse-sentence)
;;  (list 'sentence
;;        (parse-noun-phrase)
;;        (parse-verb-phrase)))
;; (define (parse-verb-phrase)
;;  (define (maybe-extend verb-phrase)
;;    (amb verb-phrase
;;         (maybe-extend (list 'verb-phrase
;;                             verb-phrase
;;                             (parse-prepositional-phrase))))
;;    (maybe-extend (parse-word verbs))))
;; (define (parse-simple-noun-phrase)
;;  (list 'simple-noun-phrase
;;        (parse-word articles)
;;        (parse-word nouns)))
;; (define (parse-noun-phrase)
;;  (define (maybe-extend noun-phrase)
;;    (amb noun-phrase
;;         (maybe-extend (list 'noun-phrase
;;                             noun-phrase
;;                             (parse-prepositional-phrase)))))
;;  (maybe-extend (parse-simple-noun-phrase)))
;; 4.3.3 Implementing the `Amb' Evaluator
;; Execution procedures and continuations
;; Structure of the evaluator
(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((perma-assignment? exp) (analyze-perma-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((if-fail? exp) (analyze-if-fail exp))
        ((lambda? exp) (analyze-lambda exp))
        ((let? exp) (analyze (let->combination exp)))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((amb? exp) (analyze-amb exp))
        ((ramb? exp) (analyze-ramb exp))
        ((require? exp) (analyze-require exp))
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type -- ANALYZE" exp))))
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
;; Simple expressions
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
;; Conditionals and sequences
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             ;; success continuation for evaluating the predicate
             ;; to obtain `pred-value'
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             ;; failure continuation for evaluating the predicate
             fail))))
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         ;; success continuation for calling `a'
         (lambda (a-value fail2)
           (b env succeed fail2))
         ;; failure continuation for calling `a'
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))
;; Definitions and assignments
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (let ((old-value (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()
                            (set-variable-value! var old-value env)
                            (fail2)))))
             fail))))
;; Procedure applications
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs)
       env
       ;; success continuation for this `aproc'
       (lambda (arg fail2)
         (get-args (cdr aprocs)
                   env
                   ;; success continuation for recursive
                   ;; call to `get-args'
                   (lambda (args fail3)
                     (succeed (cons arg args)
                              fail3))
                   fail2))
       fail)))
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else (error "Unknown procedure type -- EXECUTE-APPLICATION"
                     proc))))
;; Evaluating `amb' expressions
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices)
             env
             succeed
             (lambda ()
               (try-next (cdr choices))))))
      (try-next cprocs))))
;; Driver loop
(define amb-input-prompt ";;; Amb-Eval input:")
(define amb-output-prompt ";;; Amb-Eval value:")
(define (amb-driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input amb-input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval input
                     the-global-environment
                     ;; `ambeval' success
                     (lambda (val next-alternative)
                       (announce-output amb-output-prompt)
                       (user-print val (runtime))
                       (internal-loop next-alternative))
                     ;; `ambeval' failure
                     (lambda ()
                       (announce-output
                        ";;; There are no more values of ")
                       (user-print input (runtime))
                       (amb-driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (amb-driver-loop))))
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
;; Exercise 4.50
(define (analyze-ramb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            (let* ((random-result (pick-random choices))
                   (random-choice (car random-result))
                   (rest-choices (cdr random-result)))
              (random-choice
               env
               succeed
               (lambda ()
                 (try-next rest-choices))))))
      (try-next cprocs))))
(define (pick-random choices)
  (let ((random-idx (random (length choices))))
    (cons (list-ref choices random-idx)
          (list-rmv choices random-idx))))
(define (list-rmv items idx)
  (define (loop curr-items result curr-idx)
    (cond ((= curr-idx (length items)) result)
          ((= idx curr-idx)
           (loop (cdr curr-items) result (+ curr-idx 1)))
          (else
           (loop (cdr curr-items)
                 (append result (list (car curr-items)))
                 (+ curr-idx 1)))))
  (loop items '() 0))
(define (ramb? exp) (tagged-list? exp 'ramb))
;; Exercise 4.51
(define (perma-assignment? exp) (tagged-list? exp 'permanent-set!))
(define (analyze-perma-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (let ((old-value (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          fail2)))
             fail))))
;; Exercise 4.52
(define (if-fail? exp) (tagged-list? exp 'if-fail))
(define (analyze-if-fail exp)
  (let ((mproc (analyze (if-predicate exp)))
        (aproc (analyze (if-consequent exp))))
    (lambda (env succeed fail)
      (mproc env
             succeed
             (lambda ()
               (aproc env succeed fail))))))
;; Eval in amb
(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
;; Exercise 4.54
(define (require? exp) (tagged-list? exp 'require))
(define (require-predicate exp) (cadr exp))
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if (not pred-value)
                   (fail)
                   (succeed 'ok fail2)))
             fail))))
;; 4.4 Logic Programming
;; 4.4.1 Deductive Information Retrieval
;; A sample data base
;; Simple queries
;; Exercise 4.55
;; 1. (supervisor ?x (Bitdiddle Ben))
;; 2. (job ?x (accounting . ?y))
;; 3. (address ?x (Slumerville . ?y))
;; Compound queries
;; Exercise 4.56
;; a. (and (supervisor ?person (Bitdiddle Ben))
;;         (address ?person ?address))
;; b. (and (salary (Bitdiddle Ben) ?ben-salary)
;;         (salary ?other-person ?other-salary)
;;         (lisp-value < ?other-salary ?ben-salary))
;; c. (and (supervisor ?supervised ?supervisor)
;;         (job ?supervisor (?department . ?title))
;;         (not (job ?supervisor (computer . ?title))))
;; Rules
;; Exercise 4.57
;; (rule (can-replace ?person-1 ?person-2)
;;       (and (not (same ?person-1 ?person-2))
;;            (or (and (job ?person-1 ?job)
;;                     (job ?person-2 ?job))
;;                (and (job ?person-1 ?job-1)
;;                     (job ?person-2 ?job-2)
;;                     (can-do-job ?job-1 ?job-2)))))
;; Exercise 4.58
;; (rule (big-shot ?person ?division)
;;       (and (job ?person (?division . ?title))
;;            (supervisor ?person ?supervisor)
;;            (not (job ?supervisor (?division . ?title)))))
;; Exercise 4.59
;; a. (meeting ?department (Friday ?time))
;; b. (rule (meeting-time ?person ?day-and-time)
;;          (or (meeting whole-company ?day-and-time))
;;              (and (job ?person (?division . ?title))
;;                   (meeting ?division ?day-and-time))))
;; c. (meeting-time (Hacker Alyssa P) (Wednesday . ?time))
;; Exercise 4.60
;; Logic as programs
;; (append-to-form x y z)
;; (rule (append-to-form () ?y ?y))
;; (rule (append-to-form (?u . ?v) ?y (?u . z))
;;       (append-to-form ?v ?y ?z))
;; Exercise 4.61
;; Exercise 4.62
;; Exercise 4.63
;; (rule (grand-son ?gf ?gs
;;       (and (son ?gf ?f)
;;            (son ?f ?gs)))
;; (rule (son ?f ?s)
;;       (and (wife ?f ?w)
;;            (son ?w ?s)))
;; 4.4.2 How the Query System Works
;; Pattern matching
;; Streams of frames
;; Compound queries
;; Unification
;; Applying rules
;; Simple queries
;; The query evaluator and the driver loop
;; 4.4.3 Is Logic Programming Mathematical Logic?
;; Infinite loops
;; Problems with `not'
;; Exercise 4.64
;; (rule (outranked-by ?staff-person ?boss)
;;       (or (supervisor ?staff-person ?boss)
;;           (and (supervisor ?staff-person ?middle-manager)
;;                (outranked-by ?middle-manager ?boss))))
;; Exercise 4.65
;; (rule (wheel ?person)
;;       (and (supervisor ?middle-manager ?person)
;;            (supervisor ?x ?middle-manager)))
;; Exercise 4.66
;; Exercise 4.67
;; Exercise 4.68
;; Exercise 4.69
;; 4.4.4 Implementing the Query System
(define *op-table* (make-hash-table))
(define (put op type proc)
  (hash-table/put! *op-table* (list op type) proc))
(define (get op type)
  (hash-table/get *op-table* (list op type) #f))
;; 4.4.4.1 The Driver Loop and Instantiation
     (define input-prompt ";;; Query input:")
     (define output-prompt ";;; Query results:")

     (define (query-driver-loop)
       (prompt-for-input input-prompt)
       (let ((q (query-syntax-process (read))))
         (cond ((assertion-to-be-added? q)
                (add-rule-or-assertion! (add-assertion-body q))
                (newline)
                (display "Assertion added to data base.")
                (query-driver-loop))
               (else
                (set! THE-HISTORY '())
                (newline)
                (display output-prompt)
                (display-stream
                 (stream-map
                  (lambda (frame)
                    (instantiate q
                                 frame
                                 (lambda (v f)
                                   (contract-question-mark v))))
                  (qeval q (singleton-stream '()))))
                (query-driver-loop)))))
     (define (instantiate exp frame unbound-var-handler)
       (define (copy exp)
         (cond ((var? exp)
                (let ((binding (binding-in-frame exp frame)))
                  (if binding
                      (copy (binding-value binding))
                      (unbound-var-handler exp frame))))
               ((pair? exp)
                (cons (copy (car exp)) (copy (cdr exp))))
               (else exp)))
       (copy exp))
;; 4.4.4.2 The Evaluator
     (define (qeval query frame-stream)
       (let ((qproc (get (type query) 'qeval)))
         (if qproc
             (qproc (contents query) frame-stream)
             (simple-query query frame-stream))))
;; Simplie queries
     (define (simple-query query-pattern frame-stream)
       (stream-flatmap
        (lambda (frame)
          (stream-append-delayed
           (find-assertions query-pattern frame)
           (delay (apply-rules query-pattern frame))))
        frame-stream))
;; Compound queries
     (define (conjoin conjuncts frame-stream)
       (if (empty-conjunction? conjuncts)
           frame-stream
           (conjoin (rest-conjuncts conjuncts)
                    (qeval (first-conjunct conjuncts)
                           frame-stream))))
     (put 'and 'qeval conjoin)
     (define (disjoin disjuncts frame-stream)
       (if (empty-disjunction? disjuncts)
           the-empty-stream
           (interleave-delayed
            (qeval (first-disjunct disjuncts) frame-stream)
            (delay (disjoin (rest-disjuncts disjuncts)
                            frame-stream)))))

     (put 'or 'qeval disjoin)
;; Filters
     (define (negate operands frame-stream)
       (stream-flatmap
        (lambda (frame)
          (if (stream-null? (qeval (negated-query operands)
                                   (singleton-stream frame)))
              (singleton-stream frame)
              the-empty-stream))
        frame-stream))

     (put 'not 'qeval negate)
     (define (lisp-value call frame-stream)
       (stream-flatmap
        (lambda (frame)
          (if (execute
               (instantiate
                call
                frame
                (lambda (v f)
                  (error "Unknown pat var -- LISP-VALUE" v))))
              (singleton-stream frame)
              the-empty-stream))
        frame-stream))

     (put 'lisp-value 'qeval lisp-value)
     (define (execute exp)
       (apply (eval (predicate exp) user-initial-environment)
              (args exp)))
     (define (always-true ignore frame-stream) frame-stream)

     (put 'always-true 'qeval always-true)
;; 4.4.4.3 Finding Assertions by Pattern Matching
     (define (find-assertions pattern frame)
       (stream-flatmap (lambda (datum)
                         (check-an-assertion datum pattern frame))
                       (fetch-assertions pattern frame)))
     (define (check-an-assertion assertion query-pat query-frame)
       (let ((match-result
              (pattern-match query-pat assertion query-frame)))
         (if (eq? match-result 'failed)
             the-empty-stream
             (singleton-stream match-result))))
     (define (pattern-match pat dat frame)
       (cond ((eq? frame 'failed) 'failed)
             ((equal? pat dat) frame)
             ((var? pat) (extend-if-consistent pat dat frame))
             ((and (pair? pat) (pair? dat))
              (pattern-match (cdr pat)
                             (cdr dat)
                             (pattern-match (car pat)
                                            (car dat)
                                            frame)))
             (else 'failed)))
     (define (extend-if-consistent var dat frame)
       (let ((binding (binding-in-frame var frame)))
         (if binding
             (pattern-match (binding-value binding) dat frame)
             (extend var dat frame))))
;; 4.4.4.4 Rules and Unification
     (define (apply-rules pattern frame)
       (stream-flatmap (lambda (rule)
                         (apply-a-rule rule pattern frame))
                       (fetch-rules pattern frame)))
     (define (apply-a-rule rule query-pattern query-frame)
       (let ((clean-rule (rename-variables-in rule)))
         (let ((unify-result
                (unify-match query-pattern
                             (conclusion clean-rule)
                             query-frame)))
           (if (eq? unify-result 'failed)
               the-empty-stream
               (qeval (rule-body clean-rule)
                      (singleton-stream unify-result))))))
     (define (rename-variables-in rule)
       (let ((rule-application-id (new-rule-application-id)))
         (define (tree-walk exp)
           (cond ((var? exp)
                  (make-new-variable exp rule-application-id))
                 ((pair? exp)
                  (cons (tree-walk (car exp))
                        (tree-walk (cdr exp))))
                 (else exp)))
         (tree-walk rule)))
     (define (unify-match p1 p2 frame)
       (cond ((eq? frame 'failed) 'failed)
             ((equal? p1 p2) frame)
             ((var? p1) (extend-if-possible p1 p2 frame))
             ((var? p2) (extend-if-possible p2 p1 frame))  ; ***
             ((and (pair? p1) (pair? p2))
              (unify-match (cdr p1)
                           (cdr p2)
                           (unify-match (car p1)
                                        (car p2)
                                        frame)))
             (else 'failed)))
     (define (extend-if-possible var val frame)
       (let ((binding (binding-in-frame var frame)))
         (cond (binding
                (unify-match
                 (binding-value binding) val frame))
               ((var? val)                      ; ***
                (let ((binding (binding-in-frame val frame)))
                  (if binding
                      (unify-match
                       var (binding-value binding) frame)
                      (extend var val frame))))
               ((depends-on? val var frame)     ; ***
                'failed)
               (else (extend var val frame)))))
     (define (depends-on? exp var frame)
       (define (tree-walk e)
         (cond ((var? e)
                (if (equal? var e)
                    true
                    (let ((b (binding-in-frame e frame)))
                      (if b
                          (tree-walk (binding-value b))
                          false))))
               ((pair? e)
                (or (tree-walk (car e))
                    (tree-walk (cdr e))))
               (else false)))
       (tree-walk exp))
;; 4.4.4.5 Maintaining the Data Base
     (define THE-ASSERTIONS the-empty-stream)

     (define (fetch-assertions pattern frame)
       (if (use-index? pattern)
           (get-indexed-assertions pattern)
           (get-all-assertions)))

     (define (get-all-assertions) THE-ASSERTIONS)

     (define (get-indexed-assertions pattern)
       (get-stream (index-key-of pattern) 'assertion-stream))
     (define (get-stream key1 key2)
       (let ((s (get key1 key2)))
         (if s s the-empty-stream)))
     (define THE-RULES the-empty-stream)

     (define (fetch-rules pattern frame)
       (if (use-index? pattern)
           (get-indexed-rules pattern)
           (get-all-rules)))

     (define (get-all-rules) THE-RULES)

     (define (get-indexed-rules pattern)
       (stream-append
        (get-stream (index-key-of pattern) 'rule-stream)
        (get-stream '? 'rule-stream)))
     (define (add-rule-or-assertion! assertion)
       (if (rule? assertion)
           (add-rule! assertion)
           (add-assertion! assertion)))

     (define (add-assertion! assertion)
       (store-assertion-in-index assertion)
       (let ((old-assertions THE-ASSERTIONS))
         (set! THE-ASSERTIONS
               (cons-stream assertion old-assertions))
         'ok))

     (define (add-rule! rule)
       (store-rule-in-index rule)
       (let ((old-rules THE-RULES))
         (set! THE-RULES (cons-stream rule old-rules))
         'ok))
     (define (store-assertion-in-index assertion)
       (if (indexable? assertion)
           (let ((key (index-key-of assertion)))
             (let ((current-assertion-stream
                    (get-stream key 'assertion-stream)))
               (put key
                    'assertion-stream
                    (cons-stream assertion
                                 current-assertion-stream))))))

     (define (store-rule-in-index rule)
       (let ((pattern (conclusion rule)))
         (if (indexable? pattern)
             (let ((key (index-key-of pattern)))
               (let ((current-rule-stream
                      (get-stream key 'rule-stream)))
                 (put key
                      'rule-stream
                      (cons-stream rule
                                   current-rule-stream)))))))
     (define (indexable? pat)
       (or (constant-symbol? (car pat))
           (var? (car pat))))
     (define (index-key-of pat)
       (let ((key (car pat)))
         (if (var? key) '? key)))
     (define (use-index? pat)
       (constant-symbol? (car pat)))
;; 4.4.4.6 Stream Operations
     (define (stream-append-delayed s1 delayed-s2)
       (if (stream-null? s1)
           (force delayed-s2)
           (cons-stream
            (stream-car s1)
            (stream-append-delayed (stream-cdr s1) delayed-s2))))

     (define (interleave-delayed s1 delayed-s2)
       (if (stream-null? s1)
           (force delayed-s2)
           (cons-stream
            (stream-car s1)
            (interleave-delayed (force delayed-s2)
                                (delay (stream-cdr s1))))))
     (define (stream-flatmap proc s)
       (flatten-stream (stream-map proc s)))

     (define (flatten-stream stream)
       (if (stream-null? stream)
           the-empty-stream
           (interleave-delayed
            (stream-car stream)
            (delay (flatten-stream (stream-cdr stream))))))
     (define (singleton-stream x)
       (cons-stream x the-empty-stream))
;; 4.4.4.7 Query Syntax Procedures
     (define (type exp)
       (if (pair? exp)
           (car exp)
           (error "Unknown expression TYPE" exp)))

     (define (contents exp)
       (if (pair? exp)
           (cdr exp)
           (error "Unknown expression CONTENTS" exp)))
     (define (assertion-to-be-added? exp)
       (eq? (type exp) 'assert!))

     (define (add-assertion-body exp)
       (car (contents exp)))
     (define (empty-conjunction? exps) (null? exps))
     (define (first-conjunct exps) (car exps))
     (define (rest-conjuncts exps) (cdr exps))

     (define (empty-disjunction? exps) (null? exps))
     (define (first-disjunct exps) (car exps))
     (define (rest-disjuncts exps) (cdr exps))

     (define (negated-query exps) (car exps))

     (define (predicate exps) (car exps))
     (define (args exps) (cdr exps))
     (define (rule? statement)
       (tagged-list? statement 'rule))

     (define (conclusion rule) (cadr rule))

     (define (rule-body rule)
       (if (null? (cddr rule))
           '(always-true)
           (caddr rule)))
     (define (query-syntax-process exp)
       (map-over-symbols expand-question-mark exp))

     (define (map-over-symbols proc exp)
       (cond ((pair? exp)
              (cons (map-over-symbols proc (car exp))
                    (map-over-symbols proc (cdr exp))))
             ((symbol? exp) (proc exp))
             (else exp)))

     (define (expand-question-mark symbol)
       (let ((chars (symbol->string symbol)))
         (if (string=? (substring chars 0 1) "?")
             (list '?
                   (string->symbol
                    (substring chars 1 (string-length chars))))
             symbol)))
     (define (var? exp)
       (tagged-list? exp '?))

     (define (constant-symbol? exp) (symbol? exp))
     (define rule-counter 0)

     (define (new-rule-application-id)
       (set! rule-counter (+ 1 rule-counter))
       rule-counter)

     (define (make-new-variable var rule-application-id)
       (cons '? (cons rule-application-id (cdr var))))
     (define (contract-question-mark variable)
       (string->symbol
        (string-append "?"
          (if (number? (cadr variable))
              (string-append (symbol->string (caddr variable))
                             "-"
                             (number->string (cadr variable)))
              (symbol->string (cadr variable))))))
;; 4.4.4.8 Frames and Bindings
     (define (make-binding variable value)
       (cons variable value))

     (define (binding-variable binding)
       (car binding))

     (define (binding-value binding)
       (cdr binding))

     (define (binding-in-frame variable frame)
       (assoc variable frame))

     (define (extend variable value frame)
       (cons (make-binding variable value) frame))
(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))
;; Exercise 4.67
(define THE-HISTORY '())
;; (define (apply-a-rule rule query-pattern query-frame)
;;   (let ((clean-rule (rename-variables-in rule)))
;;     (let ((unify-result
;;            (unify-match query-pattern
;;                         (conclusion clean-rule)
;;                         query-frame)))
;;       (if (eq? unify-result 'failed)
;;           the-empty-stream
;;          (if (in-history? clean-rule unify-result)
;;              the-empty-stream
;;              (qeval (rule-body clean-rule)
;;                     (singleton-stream unify-result)))))))
;; (define (in-history? pat frame)
;;  (define (loop hist)
;;    (let ((standardized-query (standardize pat frame)))
;;      (cond ((not (has-vars? standardized-query)) false)
;;            ((null? hist)
;;             (add-to-history standardized-query)
;;             false)
;;            (else (or (sq-equal? (standardize pat frame)
;;                                 (car hist))
;;                      (loop (cdr hist)))))))
;;  (loop THE-HISTORY))
;; (define (has-vars? pat)
;;  (define (tree-walk q)
;;    (cond ((eq? q '?) true)
;;          ((pair? q)
;;           (or (tree-walk (car q))
;;               (tree-walk (cdr q))))
;;          (else false)))
;;  (tree-walk pat))
;; (define (add-to-history standardized-query)
;;  (set! THE-HISTORY (cons standardized-query THE-HISTORY)))
;; (define (standardize query frame)
;;  (define (tree-walk q)
;;    (cond ((var? q)
;;           (if (final-binding-value q frame)
;;               (final-binding-value q frame)
;;               '?))
;;          ((pair? q)
;;           (cons (tree-walk (car q))
;;                 (tree-walk (cdr q))))
;;          (else q)))
;;  (tree-walk query))
;; (define (final-binding-value var frame)
;;  (let ((binding (binding-in-frame var frame)))
;;    (if binding
;;        (if (var? (binding-value binding))
;;            (final-binding-value (binding-value binding) frame)
;;            (binding-value binding))
;;        false)))
;; (define (sq-equal? q1 q2)
;;  (define (tree-walk q1 q2)
;;    (cond ((and (pair? q1) (pair? q2))
;;           (and (tree-walk (car q1) (car q2))
;;                (tree-walk (cdr q1) (cdr q2))))
;;          ((and (not (pair? q1) ) (not (pair? q2)))
;;           (eq? q1 q2))
;;          (else false)))
;;  (tree-walk q1 q2))
;; Test
;; (define q1 '(last-pair (? v) (3)))
;; (define q2 '(last-pair (? u) (3)))
;; (define f1 (extend '(? u) 1 (extend '(? v) '(? u) '())))
;; Exercise 4.75
(define (uniquely-asserted operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (let ((qeval-result (qeval (unique-query operands)
                                (singleton-stream frame))))
       (if (and (not (stream-null? qeval-result))
                (stream-singleton? qeval-result))
           qeval-result
           the-empty-stream)))
   frame-stream))
(define (unique-query ops) (car ops))
(put 'unique 'qeval uniquely-asserted)
(define (stream-singleton? frame-stream)
  (stream-null? (stream-cdr frame-stream)))
;; Exercise 4.76
;; (define (conjoin conjuncts frame-stream)
;;  (if (empty-conjunction? conjuncts)
;;      (singleton-stream '())
;;      (let ((first-result (qeval (first-conjunct conjuncts) frame-stream))
;;            (second-result (conjoin (rest-conjuncts conjuncts) frame-stream)))
;;        (stream-flatmap
;;         (lambda (frame1)
;;           (stream-flatmap
;;            (lambda (frame2)
;;              (if (consistent-frames? frame2 frame1)
;;                  (singleton-stream (merge-frames frame1 frame2))
;;                  the-empty-stream))
;;            second-result))
;;         first-result))))
;; (put 'and 'qeval conjoin)
;; (define (consistent-frames? f1 f2)
;;  (cond ((or (frame-empty? f1) (frame-empty? f2)) true)
;;        (else (consistent-bindings? f1 f2))))
;; (define (consistent-bindings? f1 f2)
;;  (if (null? f1)
;;      true
;;      (and (check-a-binding (first-binding f1) f1 f2)
;;           (consistent-bindings? (rest-bindings f1) f2))))
;; (define (frame-empty? f) (null? f))
;; (define (first-binding f) (car f))
;; (define (rest-bindings f) (cdr f))
;; (define (check-a-binding binding f1 f2)
;;  (let* ((binding-var (car binding))
;;         (binding-val (cdr binding))
;;         (binding (binding-in-frame binding-var f2)))
;;    (if binding
;;        (compare-bindings binding-val (binding-value binding) f1 f2)
;;        true)))
;; (define (compare-bindings b1 b2 f1 f2)
;;  (cond ((var? b1)
;;         (let ((binding (binding-in-frame b1 f1)))
;;           (if binding
;;               (compare-bindings (binding-value binding) b2 f1 f2)
;;               true)))
;;        ((var? b2)
;;         (let ((binding (binding-in-frame b2 f2)))
;;           (if binding
;;               (compare-bindings b1 (binding-value binding) f1 f2)
;;               true)))
;;        ((and (pair? b1) (pair? b2))
;;         (and (compare-bindings (car b1) (car b2) f1 f2)
;;              (compare-bindings (cdr b1) (cdr b2) f1 f2)))
;;        (else (eq? b1 b2))))
;; (define (merge-frames f1 f2)
;;  (cond ((frame-empty? f1) f2)
;;        ((frame-empty? f2) f1)
;;        (else
;;         (let* ((first-f1-binding (car f1))
;;                (f1-binding-var (car first-f1-binding))
;;                (binding (binding-in-frame f1-binding-var f2)))
;;           (if binding
;;               (merge-frames (cdr f1) f2)
;;               (merge-frames (cdr f1) (cons first-f1-binding f2)))))))
;; Exercise 4.77
;; Compound queries
;; (define (conjoin conjuncts frame-stream)
;;   (define (picker conjuncts promised-filters tried-filters frame-stream)
;;     (cond ((and (null? conjuncts) (null? promised-filters))
;;            frame-stream)
;;           ((not (null? promised-filters))
;;            (let ((first-filter (car promised-filters))
;;                  (rest-filters (cdr promised-filters)))
;;              (if (all-vars-bound? first-filter frame-stream)
;;                  (picker conjuncts
;;                          rest-filters
;;                          tried-filters
;;                          (qeval first-filter frame-stream))
;;                  (picker conjuncts
;;                          rest-filters
;;                          (cons first-filter tried-filters)
;;                          frame-stream))))
;;           ((not (null? conjuncts)) ;; promised-filters must be null now
;;            (let ((first-conj (car conjuncts))
;;                  (rest-conjs (cdr conjuncts)))
;;              (if (is-filter? first-conj)
;;                  (picker rest-conjs
;;                          (cons first-conj promised-filters)
;;                          tried-filters
;;                          frame-stream)
;;                  (picker rest-conjs
;;                          tried-filters
;;                          '()
;;                          (qeval first-conj frame-stream)))))
;;           (else (error "Supposedly unreachable state -- PICKER"))))
;;   (picker conjuncts '() '() frame-stream))
;; (put 'and 'qeval conjoin)
;; (define (all-vars-bound? filter frame-stream)
;;   ;; IMPORTANT ASSUMPTION: If a variable in `filter' is bound or unbound in a
;;   ;; frame in `frame-stream', then the variable is bound or unbound in all
;;   ;; frames in `frame-stream'
;;   (cond ((var? filter)
;;          (if (stream-null? frame-stream)
;;              false
;;              (let* ((first-frame (stream-car frame-stream))
;;                     (binding (binding-in-frame filter first-frame)))
;;                (if binding
;;                    (all-vars-bound? (binding-value binding) frame-stream)
;;                    false))))
;;         ((pair? filter)
;;          (and (all-vars-bound? (car filter) frame-stream)
;;               (all-vars-bound? (cdr filter) frame-stream)))
;;         (else true)))
;; (define (is-filter? exp)
;;   (or (tagged-list? exp 'not)
;;       (tagged-list? exp 'lisp-value)))
;; Test
;; (define fr (extend '(? u) 1 (extend '(? v) '(? u) '())))
;; (define f1 '(not (? u)))
;; (define f2 '(not (? v)))
;; (define f3 '(not (? w)))
;; Exercise 4.78
;; (define amb-input-prompt ";;; Amb-Query input:")
;; (define amb-output-prompt ";;; Amb-Query result:")
;; (define (amb-driver-loop)
;;   (define (internal-loop try-again)
;;     (prompt-for-input amb-input-prompt)
;;     (let ((input (query-syntax-process (read))))
;;       (if (eq? input 'try-again)
;;           (try-again)
;;           (begin
;;             (newline)
;;             (display ";;; Starting a new query ")
;;             (ambeval input
;;                      '()
;;                      ;; `ambeval' success
;;                      (lambda (val next-alternative)
;;                        (announce-output amb-output-prompt)
;;                        (user-print
;;                         (instantiate input
;;                                      val
;;                                      (lambda (v f)
;;                                        (contract-question-mark v)))
;;                         (runtime))
;;                        (internal-loop next-alternative))
;;                      ;; `ambeval' failure
;;                      (lambda ()
;;                        (announce-output
;;                         ";;; There are no more values of ")
;;                        (user-print input (runtime))
;;                        (amb-driver-loop)))))))
;;   (internal-loop
;;    (lambda ()
;;      (newline)
;;      (display ";;; There is no current problem")
;;      (amb-driver-loop))))
;; (define (ambeval query frame succeed fail)
;;   ((analyze query) frame succeed fail))
;; (define (analyze query)
;;   (cond ((assertion-to-be-added? query) (analyze-add query))
;;         ((and-query? query) (analyze-and query))
;;         ((or-query? query) (analyze-or query))
;;         ((not-query? query) (analyze-not query))
;;         ((lisp-value? query) (analyze-lisp-value query))
;;         ((always-true? query) (analyze-always-true query))
;;         (else (analyze-simple-query query))))
;; (define (and-query? q) (tagged-list? q 'and))
;; (define (or-query? q) (tagged-list? q 'or))
;; (define (not-query? q) (tagged-list? q 'not))
;; (define (lisp-value? q) (tagged-list? q 'lisp-value))
;; (define (always-true? q) (tagged-list? q 'always-true))
;; (define (analyze-simple-query query)
;;   (lambda (frame succeed fail)
;;     (let ((assertions (fetch-assertions query frame)))
;;       (define (loop assertions)
;;         (cond ((stream-null? assertions)
;;                ((analyze-rules query) frame succeed fail))
;;               (else
;;                (let ((match-result
;;                       (pattern-match query (stream-car assertions) frame)))
;;                  (if (eq? match-result 'failed)
;;                      (loop (stream-cdr assertions))
;;                      (succeed match-result
;;                               (lambda () (loop (stream-cdr assertions)))))))))
;;       (loop assertions))))
;; (define (analyze-rules query)
;;   (lambda (frame succeed fail)
;;     (let ((rules (fetch-rules query frame)))
;;       (define (loop rules)
;;         (cond ((stream-null? rules)
;;                (fail))
;;               (else
;;                (let* ((clean-rule (rename-variables-in (stream-car rules)))
;;                       (unify-result
;;                        (unify-match query
;;                                     (conclusion clean-rule)
;;                                     frame)))
;;                  (if (eq? unify-result 'failed)
;;                      (loop (stream-cdr rules))
;;                      ((analyze (rule-body clean-rule))
;;                       unify-result
;;                       succeed
;;                       (lambda () (loop (stream-cdr rules)))))))))
;;       (loop rules))))
;; (define (analyze-add query)
;;   (lambda (frame succeed fail)
;;     (add-rule-or-assertion! (add-assertion-body query))
;;     (succeed frame fail)))
;; (define (analyze-and query)
;;   (lambda (frame succeed fail)
;;     (let ((conjuncts (contents query)))
;;       (define (loop conjuncts frame succeed fail)
;;         (if (null? conjuncts)
;;             (succeed frame fail)
;;             ((analyze (first-conjunct conjuncts))
;;              frame
;;              (lambda (first-conjunct-val fail2)
;;                (loop (rest-conjuncts conjuncts)
;;                      first-conjunct-val succeed fail2))
;;              fail)))
;;       (loop conjuncts frame succeed fail))))
;; (define (analyze-or query)
;;   (lambda (frame succeed fail)
;;     (let ((disjuncts (contents query)))
;;       (define (loop disjuncts frame succeed fail)
;;         (if (null? disjuncts)
;;             (fail)
;;             ((analyze (first-disjunct disjuncts))
;;              frame
;;              succeed
;;              (lambda ()
;;                (loop (cdr disjuncts) frame succeed fail)))))
;;       (loop disjuncts frame succeed fail))))
;; (define (analyze-not query)
;;   (lambda (frame succeed fail)
;;     (let ((operands (contents query)))
;;       (define (loop operands frame succeed fail)
;;         (if (null? operands)
;;             (succeed frame fail)
;;             ((analyze (first-operand operands))
;;              frame
;;              (lambda (val fail2)
;;                (fail))
;;              (lambda ()
;;                (loop (rest-operands operands) frame succeed fail)))))
;;       (loop operands frame succeed fail))))
;; (define (analyze-lisp-value query)
;;   (lambda (frame succeed fail)
;;     (if (execute
;;           (instantiate
;;            (contents query)
;;            frame
;;            (lambda (v f)
;;              (error "Unknown pat var -- LISP-VALUE" v))))
;;         (succeed frame fail)
;;         (fail))))
;; (define (analyze-always-true query)
;;   (lambda (frame succeed fail)
;;     (succeed frame fail)))
;; (amb-driver-loop)
;; Exercise 4.79
(define THE-ENVIRONMENT '())
(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (set! THE-ENVIRONMENT '())
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (resolve q))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
(define (apply-a-rule rule query frame)
  ;; (newline)
  ;; (display query)
  ;; (newline)
  ;; (display rule)
  ;; (newline)
  ;; (display frame)
  (let* ((remove-collisions-result
          (remove-collisions query (conclusion rule) frame))
         (clean-query (car remove-collisions-result))
         (clean-frame (cdr remove-collisions-result))
         (unify-result (unify-match clean-query (conclusion rule) frame)))
    ;; (newline)
    ;; (display unify-result)
    (if (eq? unify-result 'failed)
        '()
        (begin
          (add-binding-to-env! clean-frame unify-result)
          ;; (newline)
          ;; (display THE-ENVIRONMENT)
          ;; (newline)
          ;; (display "=============")
          (qeval-with-env (rule-body rule) unify-result)))))
(define (remove-collisions query rule frame)
  (define bindings '())
  (define (loop q)
    (cond ((null? q) '())
          ((and (var? q) (exists-in? q rule))
           (set! bindings (extend q (rename-var q) bindings))
           (rename-var q))
          ((pair? q) (cons (loop (car q)) (loop (cdr q))))
          (else q)))
  (define new-query (loop query))
  (if (not (null? bindings))
      (begin
        (add-binding-to-env! frame bindings)
        (cons new-query bindings))
      (cons query frame)))
(define (exists-in? var rule)
  (cond ((null? rule) false)
        ((var? rule) (eq? (cadr var) (cadr rule)))
        ((pair? rule) (or (exists-in? var (car rule))
                       (exists-in? var (cdr rule))))
        (else false)))
(define (rename-var var)
  (list '?
        (string->symbol
         (string-append "$"
                        (symbol->string (cadr var))))))
(define (add-binding-to-env! key value)
  (let ((binding (assoc key THE-ENVIRONMENT)))
    (if (not binding)
        (set! THE-ENVIRONMENT (extend key (list value)
                                      THE-ENVIRONMENT))
        (set-cdr! binding (cons value (binding-value binding))))))
(define (qeval-with-env query-pattern unify-result)
  (qeval (query-syntax-process
          (instantiate query-pattern unify-result
                       (lambda (v f) (contract-question-mark v))))
         (singleton-stream unify-result)))
(define (resolve q)
  (define (loop q f)
    ;; (newline)
    ;; (display q)
    ;; (newline)
    ;; (display f)
    (let ((binding (assoc f THE-ENVIRONMENT)))
      (cond ((has-no-vars? q) q)
            ((not binding)
             (instantiate q '() default-handler))
            (else
             ;; (newline)
             ;; (display (binding-value binding))
             ;; (newline)
             ;; (display "=============")

             (let ((potential-frames (binding-value binding)))
               (map (lambda (frame)
                      (loop (query-syntax-process
                             (instantiate q frame default-handler)) frame))
                    potential-frames))))))
  (loop q '()))
(define (has-no-vars? q)
  (cond ((null? q) true)
        ((var? q) false)
        ((pair? q) (and (has-no-vars? (car q))
                        (has-no-vars? (cdr q))))
        (else true)))
(define default-handler (lambda (v f) (contract-question-mark v)))
;; DEBUG
;; (set! THE-ENVIRONMENT '())
;; (define q (query-syntax-process '(append-to-form (1) (2 3) ?y)))
;; (define r (stream-car (fetch-rules q '())))
;; (define cr (remove-collisions q (conclusion r) '()))
;; (define cq (car cr))
;; (define cf (cdr cr))
;; (define ur (unify-match cq (conclusion r) '()))
;; (add-binding-to-env! cf ur)
;; (define q2 (query-syntax-process
;;               (instantiate (rule-body r) ur
;;                            (lambda (v f) (contract-question-mark v)))))
;; (define r2 (stream-car (stream-cdr (fetch-rules q '()))))
;; (define cr2 (remove-collisions q2 (conclusion r2) ur))
;; (define cq2 (car cr2))
;; (define cf2 (cdr cr2))
;; (define ur2 (unify-match cq2 (conclusion r2) ur))
;; (add-binding-to-env! cf2 ur2)
;; (define ur2 (unify-match q12 (conclusion r2) '()))
;; (define lf '(((? z) 2 3)))
;; (set! THE-ENVIRONMENT '())
;; (define q3 (query-syntax-process '(last-pair (3) (?x))))
;; (define r3 (stream-car (fetch-rules q3 '())))
;; (define cr3 (remove-collisions q3 (conclusion r3) '()))
;; (define cq3 (car cr3))
;; (define cf3 (cdr cr3))
;; (define ur3 (unify-match cq3 (conclusion r3) '()))
;; (add-binding-to-env! cf3 ur3)
;; (define q32 (query-syntax-process
;;              (instantiate (rule-body r3) ur3
;;                           (lambda (v f) (contract-question-mark v)))))
;;  (define r2 (stream-car (stream-cdr (fetch-rules q '()))))
;; (define cr2 (remove-collisions q2 (conclusion r2) ur))
;; (define cq2 (car cr2))
;; (define cf2 (cdr cr2))
;; (define ur2 (unify-match cq2 (conclusion r2) ur))
;; (add-binding-to-env! cf2 ur2)
;; (define ur2 (unify-match q12 (conclusion r2) '()))
;; (define lf '(((? z) 2 3)))
;; Building the data base
(query-driver-loop)
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
(assert! (job (Bitdiddle Ben) (computer wizard)))
(assert! (salary (Bitdiddle Ben) 60000))
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
(assert! (job (Hacker Alyssa P) (computer programmer)))
(assert! (salary (Hacker Alyssa P) 40000))
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
(assert! (job (Fect Cy D) (computer programmer)))
(assert! (salary (Fect Cy D) 35000))
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
(assert! (job (Tweakit Lem E) (computer technician)))
(assert! (salary (Tweakit Lem E) 25000))
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
(assert! (job (Reasoner Louis) (computer programmer trainee)))
(assert! (salary (Reasoner Louis) 30000))
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
(assert! (job (Warbucks Oliver) (administration big wheel)))
(assert! (salary (Warbucks Oliver) 150000))
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
(assert! (job (Scrooge Eben) (accounting chief accountant)))
(assert! (salary (Scrooge Eben) 75000))
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
(assert! (job (Cratchet Robert) (accounting scrivener)))
(assert! (salary (Cratchet Robert) 18000))
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
(assert! (job (Aull DeWitt) (administration secretary)))
(assert! (salary (Aull DeWitt) 25000))
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
(assert! (can-do-job (computer wizard) (computer programmer)))
(assert! (can-do-job (computer wizard) (computer technician)))
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
(assert! (can-do-job (administration secretary) (administration big wheel)))
;; ;; Exercise 4.62
(assert! (rule (last-pair (?x) (?x))))
(assert! (rule (last-pair (?u . ?v) (?x))
               (last-pair ?v (?x))))
;; ;; Exercise 4.63
(assert! (son Adam Cain))
(assert! (son Cain Enoch))
(assert! (son Enoch Irad))
(assert! (son Irad Mehujael))
(assert! (son Mehujael Methushael))
(assert! (son Methushael Lamech))
(assert! (wife Lamech Ada))
(assert! (son Ada Jabal))
(assert! (son Ada Jubal))
(assert! (rule (grandson ?gf ?gs)
               (and (son ?f ?gs)
                    (son ?gf ?f))))
(assert! (rule (son ?f ?s)
               (and (wife ?f ?w)
                    (son ?w ?s))))
;; Exercise 4.68
(assert! (rule (append-to-form () ?y ?y)))
(assert! (rule (append-to-form (?u . ?v) ?y (?u . ?z))
               (append-to-form ?v ?y ?z)))
(assert! (rule (reverse ?x (?u . ?v))
               (and (append-to-form ?z (?u) ?x)
                    (reverse ?v ?z))))
(assert! (rule (reverse (?u . ?v) ?x)
               (and (append-to-form ?z (?u) ?x)
                    (reverse ?v ?z))))
(assert! (rule (reverse (?x) (?x))))
;; Exercise 4.69
(assert! (rule (ends-with-grandson (grandson))))
(assert! (rule ((grandson) ?gf ?gs)
               (grandson ?gf ?gs)))
(assert! (rule (ends-with-grandson (?u . ?v))
               (ends-with-grandson ?v)))
(assert! (rule ((great . ?rel) ?x ?y)
               (and (son ?x ?z)
                    (?rel ?z ?y)
                    (Ends-with-grandson ?rel))))
(assert! (rule (same ?x ?x)))
