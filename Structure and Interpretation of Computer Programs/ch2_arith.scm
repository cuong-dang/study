;; Init functions
(define *op-table* (make-hash-table))
(define (put op type proc)
  (hash-table/put! *op-table* (list op type) proc))
(define (get op type)
  (hash-table/get *op-table* (list op type) #f))
(define (type-tag datum)
  (cond ((number? datum) 'scheme-number)
	((pair? datum) (car datum))
	(else "Bad tagged datum -- TYPE-TAG" datum)))
(define (contents datum)
  (cond ((number? datum) datum)
	((pair? datum) (cdr datum))
	(else "Bad tagged datum -- TYPE-TAG" datum)))
(define (attach-tag type-tag contents)
  (if (number? contents)
      contents
      (cons type-tag contents)))

;; Interface functions
;; Make
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (numer x) (apply-generic 'numer (list x)))
(define (denom x) (apply-generic 'denom (list x)))
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
(define (make-dense-termlist coeffs)
  ((get 'make 'dense-termlist) coeffs))
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
(define (real-part z)
  (apply-generic 'real-part (list z)))
(define (imag-part z)
  (apply-generic 'imag-part (list z)))
(define (magnitude z)
  (apply-generic 'magnitude (list z)))
(define (angle z)
  (apply-generic 'angle (list z)))
;; Arithmetic
(define (add . args) (apply-generic 'add args))
(define (sub . args) (apply-generic 'sub args))
(define (mul . args) (apply-generic 'mul args))
(define (div . args) (apply-generic 'div args))
(define (remainderg . args) (apply-generic 'remainderg args))
(define (gcdg . args) (apply-generic 'gcdg args))
(define (neg arg) (apply-generic 'neg (list arg)))
(define (squareg arg) (apply-generic 'squareg (list arg)))
(define (sqrtg arg) (apply-generic 'sqrtg (list arg)))
(define (sing arg) (apply-generic 'sing (list arg)))
(define (cosg arg) (apply-generic 'cosg (list arg)))
(define (atang arg1 arg2) (apply-generic 'atang (list arg1 arg2)))
(define (=zero? arg) (apply-generic '=zero? (list arg)))

;; Packages
;; Complex rectangular
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrtg (add (squareg (real-part z))
				(squareg (imag-part z)))))
  (define (angle z)
    (atang (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cosg a)) (mul r (sing a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part 'rectangular real-part)
  (put 'imag-part 'rectangular imag-part)
  (put 'magnitude 'rectangular magnitude)
  (put 'angle 'rectangular angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(install-rectangular-package)
;; Complex polar
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (mul (magnitude z) (cosg (angle z))))
  (define (imag-part z)
    (mul (magnitude z) (sing (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrtg (add (squareg x) (squareg y)))
          (atang y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part 'polar real-part)
  (put 'imag-part 'polar imag-part)
  (put 'magnitude 'polar magnitude)
  (put 'angle 'polar angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(install-polar-package)
;; Scheme number
(define (install-scheme-number-package)
  ;; internal procedures
  (define (=zero? x) (= x 0))
  (define (gcd-scheme-number a b)
	(if (and (integer? a) (integer? b))
		(gcd a b)
		1))
  ;; interface to the rest of the system
  (put 'add 'scheme-number +)
  (put 'sub 'scheme-number -)
  (put 'mul 'scheme-number *)
  (put 'div 'scheme-number /)
  (put 'gcdg 'scheme-number gcd-scheme-number)
  (put 'neg 'scheme-number -)
  (put 'squareg 'scheme-number square)
  (put 'sqrtg 'scheme-number sqrt)
  (put 'sing 'scheme-number sin)
  (put 'cosg 'scheme-number cos)
  (put 'atang 'scheme-number atan)
  (put 'equ? 'scheme-number =)
  (put '=zero? 'scheme-number =zero?)
  'done)
(install-scheme-number-package)
;; Rational
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
	(let ((g (gcdg n d)))
	  (cons (div n g) (div d g))))
  (define (add-rat x y)
	;; only change `add-rat' to generic operations
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (neg-rat x)
	(make-rat (- (numer x)) (denom x)))
  (define (square-rat x)
	(make-rat (squareg (numer x))
			  (squareg (denom x))))
  (define (sqrt-rat x)
	(make-rat (sqrtg (numer x))
			  (sqrtg (denom x))))
  (define (sin-rat x)
	(sing (/ (numer x) (denom x))))
  (define (cos-rat x)
	(cosg (/ (numer x) (denom x))))
  (define (atan-rat x y)
	(atang (/ (numer x) (denom x)) (/ (numer y) (denom y))))
  (define (equ?-rat x y)
    (and (= (numer x) (numer y))
		 (= (denom x) (denom y))))
  (define (=zero?-rat x)
	(= (numer x) 0))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'numer 'rational numer)
  (put 'denom 'rational denom)
  (put 'add 'rational
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub 'rational
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul 'rational
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div 'rational
       (lambda (x y) (tag (div-rat x y))))
  (put 'neg 'rational
	   (lambda (x) (tag (neg-rat x))))
  (put 'squareg 'rational
	   (lambda (x) (tag (square-rat x))))
  (put 'sqrtg 'rational
	   (lambda (x) (tag (sqrt-rat x))))
  (put 'sing 'rational
	   (lambda (x) (tag (sin-rat x))))
  (put 'cosg 'rational
	   (lambda (x) (tag (cos-rat x))))
  (put 'atang 'rational
	   (lambda (x y) (tag (atan-rat x y))))
  (put 'equ? 'rational equ?-rat)
  (put '=zero? 'rational =zero?-rat)
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
(install-rational-package)
;; Complex
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; interval procedures
  (define (real-part z) (apply-generic 'real-part (list z)))
  (define (imag-part z) (apply-generic 'imag-part (list z)))
  (define (magnitude z) (apply-generic 'magnitude (list z)))
  (define (angle z) (apply-generic 'angle (list z)))
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  (define (neg-complex z)
	(make-from-real-imag (neg (real-part z))
						 (neg (imag-part z))))
  (define (equ?-complex z1 z2)
    (and (equ? (real-part z1) (real-part z2))
		 (equ? (imag-part z1) (imag-part z2))))
  (define (=zero?-complex z)
	(and (=zero? (real-part z))
		 (=zero? (imag-part z))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'complex x))
  (put 'real-part 'complex real-part)
  (put 'imag-part 'complex imag-part)
  (put 'magnitude 'complex magnitude)
  (put 'angle 'complex angle)
  (put 'add 'complex
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub 'complex
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul 'complex
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div 'complex
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'neg 'complex
	   (lambda (z) (tag (neg-complex z))))
  (put 'equ? 'complex equ?-complex)
  (put '=zero? 'complex =zero?-complex)
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(install-complex-package)
;; Dense term list
(define (install-dense-termlist)
  ;; internal procedures
  (define (the-empty-termlist) '())
  (define (first-term term-list)
	(list (- (length term-list) 1) (car term-list)))
  (define (rest-terms term-list)
	(cdr term-list))
  (define (coeffs term-list) term-list)
  (define (empty-termlist? term-list) (null? term-list))
  (define (adjoin-term term term-list)
	(define (iter coeff order term-list)
	  (let ((highest-term-list-order (- (length term-list) 1)))
		(cond ((=zero? coeff) term-list)
			  ((> order highest-term-list-order)
			   (iter coeff order (append '(0) term-list)))
			  ((= order highest-term-list-order)
			   (cons (add coeff (car term-list)) (cdr term-list)))
			  ((< order highest-term-list-order)
			   (cons (car term-list)
					 (iter coeff order (cdr term-list)))))))
	(let ((term-order (order term))
		  (term-coeff (coeff term)))
	  (iter term-coeff term-order term-list)))
  (define (op-k-coeffs tlst op k)
	(map (lambda (term) (op term k)) tlst))
  (define (neg-termlist term-list)
	(map neg term-list))
  (define (equ?-termlist tlst1 tlst2)
	(cond ((and (empty-termlist? tlst1) (empty-termlist? tlst2)) true)
		  ((or (empty-termlist? tlst1) (empty-termlist? tlst2)) false)
		  (else
		   (let ((coeff1 (coeff (first-term tlst1)))
				 (coeff2 (coeff (first-term tlst2))))
			 (if (equ? coeff1 coeff2)
				 (equ?-termlist (rest-terms tlst1) (rest-terms tlst2))
				 false)))))
  ;; interface to rest of the system
  (define (tag tlst) (attach-tag 'dense-termlist tlst))
  (put 'make 'dense-termlist
	   (lambda (coeffs) (tag coeffs)))
  (put 'the-empty-termlist 'dense-termlist
	   (lambda () (tag (the-empty-termlist))))
  (put 'first-term 'dense-termlist first-term)
  (put 'rest-terms 'dense-termlist
	   (lambda (tlst) (tag (rest-terms tlst))))
  (put 'coeffs 'dense-termlist coeffs)
  (put 'empty-termlist? 'dense-termlist empty-termlist?)
  (put 'adjoin-term 'dense-termlist
	   (lambda (t tlst) (tag (adjoin-term t tlst))))
  (put 'op-k-coeffs 'dense-termlist
	   (lambda (tlst op k) (tag (op-k-coeffs tlst op k))))
  (put 'neg 'dense-termlist
	   (lambda (tlst) (tag (neg-termlist tlst))))
  (put 'equ? 'dense-termlist equ?-termlist)
  'done)
(install-dense-termlist)
;; Poly
(define (install-polynomial-package)
  ;; imported dependencies
  ;; empty term list defaults to be empty dense term list
  (define the-empty-termlist (get 'the-empty-termlist 'dense-termlist))
  (define (first-term tlst)
	((get 'first-term 'dense-termlist) (contents tlst)))
  (define (rest-terms tlst)
	((get 'rest-terms 'dense-termlist) (contents tlst)))
  (define (coeffs tlst)
	((get 'coeffs 'dense-termlist) (contents tlst)))
  (define (empty-termlist? tlst)
	((get 'empty-termlist? 'dense-termlist) (contents tlst)))
  (define (adjoin-term t tlst)
	((get 'adjoin-term (type-tag tlst)) t (contents tlst)))
  (define (op-k-coeffs tlst op k)
	((get 'op-k-coeffs 'dense-termlist) (contents tlst) op k))
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
	(and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (dummy-variable? v)
	(equal? v 0))
  (define (equ?-poly p1 p2)
	(and (same-variable? p1 p2)
		 (equ? (term-list p1) (term-list p2))))
  (define (=zero?-poly p)
	(let ((coeff-list (coeffs (term-list p))))
	  (=zero? (apply add (cons 0 coeff-list)))))
  ;; operations on poly
  (define (add-terms L1 L2)
	(cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
			 (cond ((> (order t1) (order t2))
					(adjoin-term
					 t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
					(adjoin-term
					 t2 (add-terms L1 (rest-terms L2))))
                   (else
					(adjoin-term
					 (make-term (order t1)
								(add (coeff t1) (coeff t2)))
					 (add-terms (rest-terms L1)
								(rest-terms L2)))))))))
  (define (sub-terms L1 L2)
	(add-terms L1 (neg L2)))
  (define (mul-terms L1 L2)
	(if (empty-termlist? L1)
		(the-empty-termlist)
		(add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
	(if (empty-termlist? L)
		(the-empty-termlist)
		(let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (div-terms L1 L2)
	(if (empty-termlist? L1)
		(list (the-empty-termlist) (the-empty-termlist))
		(let ((t1 (first-term L1))
			  (t2 (first-term L2)))
		  (if (> (order t2) (order t1))
			  (list (the-empty-termlist) L1)
			  (let ((new-c (div (coeff t1) (coeff t2)))
					(new-o (sub (order t1) (order t2))))
				(let ((rest-of-result
					   (div-terms
						(sub-terms L1 (mul-terms
									   (adjoin-term (list new-o new-c)
													(the-empty-termlist))
									   L2))
						L2)))
				  (list (adjoin-term (list new-o new-c)
									 (car rest-of-result))
						(cadr rest-of-result))))))))
  (define (add-mul-poly-template p1 p2 combine-terms)
	(define (select-non-dummy-var v1 v2)
	  (if (dummy-variable? v1) v2 v1))
	(let ((v1 (variable p1)) (v2 (variable p2)))
	  (cond ((same-variable? v1 v2)
			 (make-poly v1
						(combine-terms (term-list p1)
									   (term-list p2))))
			((or (dummy-variable? v1) (dummy-variable? v2))
			 (make-poly (select-non-dummy-var v1 v2)
						(combine-terms (term-list p1)
									   (term-list p2))))
			((> (var-hierarchy v1) (var-hierarchy v2))
			 (add-mul-poly-template p1 (varcast-poly p2 v1) combine-terms))
			(else
			 (add-mul-poly-template (varcast-poly p1 v2) p2 combine-terms)))))
  (define (add-poly p1 p2)
	(add-mul-poly-template p1 p2 add-terms))
  (define (negate-poly p)
	(make-poly (variable p)
			   (neg (term-list p))))
  (define (sub-poly p1 p2)
	(add-poly p1 (negate-poly p2)))
  (define (mul-poly p1 p2)
	(add-mul-poly-template p1 p2 mul-terms))
  (define (div-poly-with-remainder p1 p2)
	(if (same-variable? (variable p1) (variable p2))
		(let ((div-result (div-terms (term-list p1) (term-list p2))))
		  (list (make-poly (variable p1) (car div-result))
				(make-poly (variable p1) (cadr div-result))))
		(error "Polys not in same var -- MUL-POLY"
               (list p1 p2))))
  (define (div-poly p1 p2)
	(car (div-poly-with-remainder p1 p2)))
  (define (remainder-poly p1 p2)
	(cadr (div-poly-with-remainder p1 p2)))
  (define (remainder-terms a b)
	(cadr (div-terms a b)))
  (define (gcd-terms a b)
	(if (empty-termlist? b)
		a
		(gcd-terms b (pseudoremainder-terms a b))))
  (define (gcd-poly p1 p2)
	(let ((v1 (variable p1)) (v2 (variable p2)))
	  (if (same-variable? v1 v2)
		  (let ((result-terms (gcd-terms (term-list p1) (term-list p2))))
			(if (= (length (contents result-terms)) 1)
				(make-poly v1 result-terms)
				(let ((gcd-coeffs (apply gcdg (coeffs result-terms))))
				  (make-poly v1 (op-k-coeffs result-terms div gcd-coeffs)))))
		  (error "Polys not in same var -- GCD-POLY"
				 (list p1 p2)))))
  (define (div-poly-with-pseudoremainder p1 p2)
	(let ((v1 (variable p1)) (v2 (variable p2))
		  (largest-order-p1 (order (first-term (term-list p1))))
		  (largest-order-p2 (order (first-term (term-list p2))))
		  (leading-coeff-p2 (coeff (first-term (term-list p2)))))
	  (let ((int-factor (expt leading-coeff-p2
							  (+ 1 (- largest-order-p1 largest-order-p2)))))
		(div-poly-with-remainder
		 (contents (mul (make-polynomial v1 (term-list p1)) int-factor))
		 p2))))
  (define (div-poly-pseudo p1 p2)
	(car (div-poly-with-pseudoremainder p1 p2)))
  (define (remainder-poly-pseudo p1 p2)
	(cadr (div-poly-with-pseudoremainder p1 p2)))
  (define (pseudoremainder-terms a b)
	(let ((largest-order-p (order (first-term a)))
		  (largest-order-q (order (first-term b)))
		  (leading-coeff-q (coeff (first-term b))))
	  (let ((int-factor (expt leading-coeff-q
							  (+ 1 (- largest-order-p largest-order-q)))))
		(cadr (div-terms (op-k-coeffs a mul int-factor)
						 (op-k-coeffs b mul int-factor))))))

  ;; dealing with poly coercions
  (define (varcast-poly p to-var)
	(define (varcast-complex-term from-var c o)
	  (let ((multiplier
			 (make-polynomial from-var (adjoin-term (list o 1)
													(the-empty-termlist))))
			(multiplicands (coeffs (term-list c))))
		(make-poly to-var
				   (make-dense-termlist
					(map (lambda (multiplicand)
						   (mul multiplier multiplicand))
						 multiplicands)))))
	(define (varcast-simple-term from-var c o)
	  (make-poly
	   to-var
	   (make-dense-termlist
		(list (make-polynomial from-var
							   (adjoin-term (list o c)
											(the-empty-termlist)))))))
	(define (termlist-to-poly from-var tlst)
	  (if (empty-termlist? tlst)
		  (make-poly to-var (the-empty-termlist))
		  (let ((t (first-term tlst)) (rest (rest-terms tlst)))
			(let ((c (coeff t)) (o (order t)))
			  (cond ((and (eq? (type-tag c) 'polynomial)
						  (same-variable? (variable (contents c)) to-var))
					 (add-poly (varcast-complex-term from-var (contents c) o)
							   (termlist-to-poly from-var rest)))
					((and (eq? (type-tag c) 'polynomial)
						  (not (same-variable? (variable (contents c))
											   to-var)))
					 (let ((new-poly (varcast-poly (contents c) to-var)))
					   (add-poly (varcast-complex-term from-var new-poly o)
								 (termlist-to-poly from-var rest))))
					(else
					 (add-poly (varcast-simple-term from-var c o)
							   (termlist-to-poly from-var rest))))))))
	(let ((from-var (variable p))
		  (tlst (term-list p)))
	  (termlist-to-poly from-var tlst)))
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add 'polynomial
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'sub 'polynomial
	   (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'mul 'polynomial
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'div 'polynomial
	   (lambda (p1 p2) (tag (div-poly p1 p2))))
  (put 'remainderg 'polynomial
	   (lambda (p1 p2) (tag (remainder-poly p1 p2))))
  (put 'gcdg 'polynomial
	   (lambda (p1 p2) (tag (gcd-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  (put 'equ? 'polynomial equ?-poly)
  (put '=zero? 'polynomial =zero?-poly)
  (put 'variable 'polynomial variable)
  (put 'term-list 'polynomial term-list)
  'done)
(install-polynomial-package)
;; Type casts
(define (install-type-cast-package)
  ;; imported procedures
  (define numer	(get 'numer 'rational))
  (define denom	(get 'denom 'rational))
  (define make-dense-termlist (get 'make 'dense-termlist))
  (define variable (get 'variable 'polynomial))
  (define term-list (get 'term-list 'polynomial))
  ;; internal procedures
  (define (raise-scheme-number x) (make-rational x 1))
  (define (project-scheme-number x) false)
  (define (raise-rational x)
	(make-from-real-imag (make-rational (numer x) (denom x)) 0))
  (define (project-rational x) (numer x))
  (define (raise-complex z)
	;; raise to a polynomial with dummy variable `0', later to be handled by
	;; `same-variable?' in `polynomial' packge. This badly breaks down the
	;; abstraction barriers but necessary given how we have been trying to
	;; coerce by repeatedly raising instead of a coercion table. The best
	;; scheme is probably a coercion table with a coercion path graph.
	(make-polynomial '0 (make-dense-termlist
						 (list (make-from-real-imag (real-part z)
													(imag-part z))))))
  (define (project-complex z)
	(if (eq? (type-tag (real-part z)) 'scheme-number)
		(make-rational (contents (real-part z)) 1)
		(real-part z)))
  (define (project-dense-termlist tlst) false)
  (define (raise-dense-termlist tlst) false)
  (define (raise-project-poly-template p proc)
	(let ((var (car p))
		  (tlst (cdr p)))
	  (let ((new-termlist-contents (map proc (contents tlst))))
		(if (contains-false? new-termlist-contents)
			(make-polynomial (variable p) (term-list p))
			(make-polynomial var
							 (make-dense-termlist new-termlist-contents))))))
  (define (contains-false? new-termlist-contents)
	(cond ((null? new-termlist-contents) false)
		  ((car new-termlist-contents)
		   (contains-false? (cdr new-termlist-contents)))
		  (else true)))
  (define (project-poly p)
	(raise-project-poly-template p project))
  (define (raise-poly p)
	(raise-project-poly-template p raise))
  ;; interface to rest of the system
  (put 'raise 'scheme-number raise-scheme-number)
  (put 'project 'scheme-number project-scheme-number)
  (put 'raise 'rational raise-rational)
  (put 'project 'rational project-rational)
  (put 'raise 'complex raise-complex)
  (put 'project 'complex project-complex)
  (put 'raise 'dense-termlist raise-dense-termlist)
  (put 'project 'dense-termlist project-dense-termlist)
  (put 'raise 'polynomial raise-poly)
  (put 'project 'polynomial project-poly)
  'done)
(install-type-cast-package)

;; Package functions
(define (apply-generic op args)
  (define (handle-arg-length proc args)
	(if (> (length args) 2)
		(proc (contents (car args))
			  (contents (handle-arg-length proc (cdr args))))
		(apply proc (map contents args))))
  (let ((type-tags (map type-tag args)))
	(if (all-eq? type-tags)
		(let ((proc (get op (car type-tags))))
		  (if proc
			  (drop (handle-arg-length proc args))
			  (error "No method for these types"
					 (list op type-tags))))
		(let ((new-args (try-raise args type-tags)))
		  (if (not (null? new-args))
			  (apply-generic op new-args)
			  (error "No method for these types"
					 (list op type-tags)))))))
(define (try-raise args type-tags)
  (let ((type-hierarchies (map type-hierarchy args)))
	(let ((highest-hierarchy (apply max type-hierarchies)))
	  (define (helper args type-hierarchies new-args)
		(if (null? args)
			new-args
			(helper (cdr args)
					(cdr type-hierarchies)
					(append
					 new-args
					 (list ((repeated raise (- highest-hierarchy
											   (car type-hierarchies)))
							(car args)))))))
	  (helper args type-hierarchies '()))))
(define (all-eq? type-tags)
  (define (iter type-tags first-type)
	(cond ((null? type-tags) true)
		  ((not (eq? first-type (car type-tags))) false)
		  (else (iter (cdr type-tags) first-type))))
  (if (null? type-tags)
	  false
	  (iter (cdr type-tags) (car type-tags))))
(define (repeated p n)
  (cond ((= n 0) (lambda (x) x))
	((= n 1) p)
	(else (lambda (x) (p ((repeated p (- n 1)) x))))))
(define (equ? x y)
  ;; cannot use `apply-generic' due to raise coercion
  (let ((x-type (type-tag x))
		(y-type (type-tag y)))
	(if (eq? x-type y-type)
		((get 'equ? x-type) (contents x) (contents y))
		false)))
(define (raise x)
  ;; cannot use `apply-generic' due to final `drop' behavior
  ((get 'raise (type-tag x)) (contents x)))
(define (project x)
  ;; cannot use `apply-generic' due to dinal `drop' behavior
  ((get 'project (type-tag x)) (contents x)))
(define (type-hierarchy x)
  (let ((type (type-tag x)))
	(cond ((eq? type 'scheme-number) 0)
		  ((eq? type 'rational) 1)
		  ((eq? type 'complex) 2)
		  ((eq? type 'polynomial) 3))))
(define (var-hierarchy var)
  (cond ((equal? var 0) 0)
		((equal? var 'z) 1)
		((equal? var 'y) 2)
		((equal? var 'x) 3)))
(define (drop x)
  (if (boolean? x)
	  x
	  (let ((projected (project x)))
		(if projected
			(let ((raised (raise projected)))
			  (if (equ? raised x)
				  (drop projected)
				  x))
			x))))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))

;; DEBUG
(define n 1)
(define r (make-rational 1 1))
(define z (make-from-real-imag 1 0))
(define zc (make-from-real-imag (make-rational 1 2) (make-rational 1 3)))
(define zero-poly (make-polynomial 'x '((3 0) (1 (rational 0 . 5)) (0 0))))
(define p1 (make-polynomial 'x '(dense-termlist 3 0 1 1)))
(define p2 (make-polynomial 'x '(dense-termlist 2 2 1)))
(define pc1 '(polynomial x dense-termlist 1 2 1))
(define pc2 '(polynomial y dense-termlist
						 (polynomial x dense-termlist 1 0)
						 (polynomial x dense-termlist 1 3)
						 0))
(define pc3 '(polynomial y dense-termlist
						 (polynomial z dense-termlist
									 (polynomial x dense-termlist 1 0) 0)
						 (polynomial z dense-termlist
									 (polynomial x dense-termlist 1 1)
									 0
									 (polynomial x dense-termlist 3 0))
						 0))
(define p3 '(polynomial x dense-termlist 1 1))
(define p4 '(polynomial x dense-termlist 1 0 1))
(define rf (make-rational p4 p3))
(define p1 '(polynomial x dense-termlist 1 -1 -2 2 0))
(define p2 '(polynomial x dense-termlist 1 0 -1 0))
(define p1 '(polynomial x dense-termlist 1 -2 1))
(define p2 '(polynomial x dense-termlist 11 0 7))
(define p3 '(polynomial x dense-termlist 13 5))
(define q1 (mul p1 p2))
(define q2 (mul p1 p3))

(define p1 '(polynomial x dense-termlist 1 1))
(define p2 '(polynomial x dense-termlist 1 0 0 -1))
(define p3 '(polynomial x dense-termlist 1 0))
(define p4 '(polynomial x dense-termlist 1 0 -1))
(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))

(add rf1 rf2)
