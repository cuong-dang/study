;Chapter 2
;Building Abstractions with Data
(define (linear-combination a b x y)
  (+ (* a x) (* b y)))
(define (linear-combination a b x y)
  (add (mul a x) (mul b y)))
;2.1 Introduction to Data Abstraction
;;2.1.1 Example: Arithmetic Operations for Rational Numbers
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
	    (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
	    (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
;;;Pairs
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
;;;Representing rational numbers
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
;;Exercise 2.1.
(define (make-rat n d)
  (let ((sign (/ (* n d) (* (abs n) (abs d))))
	(g (gcd (abs n) (abs d))))
    (cons (* sign (/ (abs n) g)) (/ (abs d) g))))
;;2.1.2 Abstraction Barriers
;;Exercise 2.2.
(define (make-segment start-point end-point)
  (cons start-point end-point))
(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (cdr segment))
(define (make-point x y)
  (cons x y))
(define (x-point point)
  (car point))
(define (y-point point)
  (cdr point))
(define (midpoint-segment segment)
  (let ((start-point (start-segment segment))
	(end-point (end-segment segment)))
    (make-point (avg (x-point start-point)
		     (x-point end-point))
		(avg (y-point start-point)
		     (y-point end-point)))))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (avg x y)
  (/ (+ x y) 2.0))
;;Exercise 2.3.
(define (make-rectangle point1 point2)
  (cons point1 point2))
(define (start-point-rectangle r)
  (car r))
(define (end-point-rectangle r)
  (cdr r))
(define (height-rectangle r)
  (let ((start-point (start-point-rectangle r))
	(end-point (end-point-rectangle r)))
    (length-segment (make-segment start-point
				  (make-point (x-point start-point)
					      (y-point end-point))))))
(define (width-rectangle r)
  (let ((start-point (start-point-rectangle r))
	(end-point (end-point-rectangle r)))
    (length-segment (make-segment start-point
				  (make-point (x-point end-point)
					      (y-point start-point))))))
(define (perimeter-rectangle r)
  (* 2 (+ (height-rectangle r)
	  (width-rectangle r))))
(define (area-rectangle r)
  (* (height-rectangle r) (width-rectangle r)))
(define (length-segment segment)
  (let ((start-point (start-segment segment))
	(end-point (end-segment segment)))
    (let ((x1 (x-point start-point))
	  (x2 (x-point end-point))
	  (y1 (y-point start-point))
	  (y2 (y-point end-point)))
      (sqrt (+ (square (- x2 x1))
	       (square (- y2 y1)))))))
(define (make-rectangle start-point x-delta y-delta)
  (cons start-point (cons x-delta y-delta)))
(define (start-point-rectangle r)
  (car r))
(define (x-delta r)
  (cadr r))
(define (y-delta r)
  (cddr r))
(define (height-rectangle r)
  (abs (y-delta r)))
(define (width-rectangle r)
  (abs (x-delta r)))
;;2.1.3 What Is Meant by Data?
(define (cons2 x y)
  (define (dispatch m)
    (cond ((= m 0) x)
	  ((= m 1) y)
	  (else (error "Argument not 0 or 1 -- CONS2" m))))
  dispatch)
(define (car2 z) (z 0))
(define (cdr2 z) (z 1))
;;Exercise 2.4.
(define (cons3 x y)
  (lambda (m) (m x y)))
(define (car3 z)
  (z (lambda (p q) p)))
(define (cdr3 z)
  (z (lambda (p q) q)))
;;Exercise 2.5.
(define (cons4 x y)
  (* (expt 2 x) (expt 3 y)))
(define (car4 z)
  (define (iter res)
    (let ((try (expt 2 res)))
      (if (not (= (modulo z try) 0))
	  (- res 1)
	  (iter (+ res 1)))))
  (iter 0))
(define (cdr4 z)
  (/ (log (/ z (expt 2 (car4 z))))
     (log 3)))
;;Exercise 2.6.
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
;;2.1.4 Extended Exercise: Interval Arithmetic
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
		 (+ (upper-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
	(p2 (* (lower-bound x) (upper-bound y)))
	(p3 (* (upper-bound x) (lower-bound y)))
	(p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
		   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval x
		(make-interval (/ 1.0 (upper-bound y))
			       (/ 1.0 (lower-bound y)))))
;;Exercise 2.7.
(define (make-interval a b) (cons a b))
(define (lower-bound x) (car x))
(define (upper-bound x) (cdr x))
;;Exercise 2.8.
(define (sub-interval x y)
  (add-interval x
		(make-interval (- (upper-bound y))
			       (- (lower-bound y)))))
;;Exercise 2.9.
(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))
;;;w_(x+y) = w_x + w_y (from definition)
;;;[solution]
;;;If the width of the result was a function of the widths of the inputs,
;;;then multiplying different intervals with the same width should give
;;;the same answer. But in fact, this is not true.
;;Exercise 2.10.
(define (div-interval x y)
  (if (or (= (lower-bound y) 0)p
	  (= (upper-bound y) 0))
      (error "Divides by interval spanning 0 -- DIV-INTERVAL" y)
      (mul-interval x
		    (make-interval (/ 1.0 (upper-bound y))
				   (/ 1.0 (lower-bound y))))))
;;Exercise 2.11.
(define (mul-interval x y)
  (define (neg? x)
    (negative? x))
  (define (pos? x)
    (not (negative? x)))
  (let ((xl (lower-bound x))
	(xu (upper-bound x))
	(yl (lower-bound y))
	(yu (upper-bound y)))
    (cond ((and (pos? xl) (pos? xu) (pos? yl) (pos? yu))
	   (make-interval (* xl yl) (* xu yu)))
	  ((and (neg? xl) (pos? xu) (pos? yl) (pos? yu))
	   (make-interval (* xl yu) (* xu yu)))
	  ((and (pos? xl) (pos? xu) (neg? yl) (pos? yu))
	   (make-interval (* xu yl) (* xu yu)))
	  ((and (neg? xl) (neg? xu) (pos? yl) (pos? yu))
	   (make-interval (* xl yu) (* xl yl)))
	  ((and (pos? xl) (pos? xu) (neg? yl) (neg? yu))
	   (make-interval (* xu yl) (* xl yu)))
	  ((and (neg? xl) (pos? xu) (neg? yl) (pos? yu))
	   (make-interval (min (* xl yu) (* xu yl))
			  (max (* xl yl) (* xu yu))))
	  ((and (neg? xl) (neg? xu) (neg? yl) (pos? yu))
	   (make-interval (* xl yu) (* xl yl)))
	  ((and (neg? xl) (pos? xu) (neg? yl) (neg? yu))
	   (make-interval (* xu yl) (* xl yl)))
	  ((and (neg? xl) (neg? xu) (neg? yl) (neg? yu))
	   (make-interval (* xu yu) (* xl yl))))))

(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
;;Exercise 2.12.
(define (make-center-percent c p)
  (let ((w (* c p)))
    (make-interval (- c w) (+ c w))))
(define (percent i)
  (/ (width i) (center i)))
;;Exercise 2.13.
;;;p_xy = \frac{p_x + p_y}{1 + p_xp_y}
;;;p_xy \approx p_x + p_y
;;Exercise 2.14.
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
		(add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one
		  (add-interval (div-interval one r1)
				(div-interval one r2)))))
;;Exercise 2.15.
;;;[solution] http://wiki.drewhess.com/wiki/SICP_exercise_2.15
;;Exercise 2.16.
;;;[solution] http://wiki.drewhess.com/wiki/SICP_exercise_2.16
;2.2 Hierarchical Data and the Closure Property
;;2.2.1 Representing Sequences
;;;List operations
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define (length items)
  (define (length-iter a count)
    (if (null? a)
	count
	(length-iter (cdr a) (+ count 1))))
  (length-iter items 0))
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
;;Exercise 2.17.
(define (last-pair items)
  (cond ((null? items) '())
	((= (length items) 1) (car items))
	(else (last-pair (cdr items)))))
;;Exercise 2.18
(define (reverse items)
  (define (reverse-iter items res)
    (if (null? items)
	res
	(reverse-iter (cdr items) (cons (car items) res))))
  (reverse-iter items '()))
;;Exercise 2.19
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
	((or (< amount 0) (no-more? coin-values)) 0)
	(else
	 (+ (cc amount
		(except-first-denomination coin-values))
	    (cc (- amount (first-denomination coin-values))
		coin-values)))))
(define (no-more? coin-values)
  (null? coin-values))
(define (except-first-denomination coin-values)
  (cdr coin-values))
(define (first-denomination coin-values)
  (car coin-values))
;;;The order of the list coin-values does not affect the answer produced by cc.
;;;The reason is that none of the procedures depend on the order of list coin-values.
;;Exercise 2.20.
(define (same-parity first . rest)
  (define (same-parity-iter first rest res)
    (if (null? rest)
	(cons first res)
	(let ((first-of-rest (car rest)))
	  (if (= (modulo first 2)
		 (modulo first-of-rest 2))
	      (same-parity-iter first (cdr rest) (append res (list first-of-rest)))
	      (same-parity-iter first (cdr rest) res)))))
  (same-parity-iter first rest '()))
;;;Mapping over lists
(define (scale-list items factor)
  (if (null? items)
      '()
      (cons (* (car items) factor)
	    (scale-list (cdr items) factor))))
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
	    (map proc (cdr items)))))
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
;;Exercise 2.21.
(define (square-list items)
  (if (null? items)
      '()
      (cons (square (car items))
	    (square-list (cdr items)))))
(define (square-list items)
  (map square items))
;;Exercise 2.22.
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) 
              (cons (square (car things))
                    answer))))
  (iter items '()))
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (append answer
		      (list (square (car things)))))))
  (iter items '()))
;;Exercise 2.23.
(define (for-each proc items)
  (cond ((not (null? items))
	 (proc (car items))
	 (for-each proc (cdr items)))))
;;2.2.2 Hierarchical Structures
(define (count-leaves x)
  (cond ((null? x) 0)
	((not (pair? x)) 1)
	(else (+ (count-leaves (car x))
		  (count-leaves (cdr x))))))
;;Exercise 2.24.
;;Exercise 2.25.
;;;cadaddr
;;;caar
;;;cadadadadadadr
;;Exercise 2.26.
;;;'(1 2 3 4 5 6)
;;;'((1 2 3) 4 5 6)
;;;'((1 2 3) (4 5 6))
;;Exercise 2.27.
(define (deep-reverse x)
  (cond ((null? x) '())
	((pair? (car x)) (append (deep-reverse (cdr x))
				 (list (deep-reverse (car x)))))
	(else (append (deep-reverse (cdr x)) (list (car x))))))
;;Exercise 2.28.
(define (fringe tree)
  (cond ((null? tree) '())
	((pair? (car tree)) (append (fringe (car tree)) (fringe (cdr tree))))
	(else (cons (car tree) (fringe (cdr tree))))))
;;Exercise 2.29.
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
;;;a.
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))
;;;b.
(define (total-weight mobile)
  (let ((left-br (left-branch mobile))
	(right-br (right-branch mobile)))
    (cond ((and (has-weight? left-br) (has-weight? right-br))
	   (+ (branch-structure left-br)
	      (branch-structure right-br)))
	  ((has-weight? left-br)
	   (+ (branch-structure left-br)
	      (total-weight (branch-structure right-br))))
	  ((has-weight? right-br)
	   (+ (total-weight (branch-structure left-br))
	      (branch-structure right-br)))
	  (else
	   (+ (total-weight (branch-structure left-br))
	      (total-weight (branch-structure right-br)))))))
(define (has-weight? branch)
  (not (pair? (branch-structure branch))))
;;;testing mobile
(define m4bl (make-branch 3 7))
(define m4br (make-branch 5 9))
(define m4 (make-mobile m4bl m4br))
(define m3bl (make-branch 1 1))
(define m3br (make-branch 7 8))
(define m3 (make-mobile m3bl m3br))
(define m2bl (make-branch 1 m3))
(define m2br (make-branch 2 m4))
(define m2 (make-mobile m2bl m2br))
(define m1bl (make-branch 2 m2))
(define m1br (make-branch 5 4))
(define m1 (make-mobile m1bl m1br))
(define m0bl (make-branch 3 10))
(define m0br (make-branch 5 m1))
(define m0 (make-mobile m0bl m0br))
;;;c.
(define (balanced? mobile)
  (let ((left-br (left-branch mobile))
	(right-br (right-branch mobile)))
    (cond ((and (has-weight? left-br) (has-weight? right-br))
	   (= (branch-torque left-br) (branch-torque right-br)))
	  ((has-weight? left-br)
	   (and (= (branch-torque left-br) (branch-torque right-br))
		(balanced? (branch-structure right-br))))
	  ((has-weight? right-br)
	   (and (= (brach-torque left-br) (branch-torque right-br))
		(balanced? (branch-structure left-br))))
	  (else
	   (and (= (branch-torque left-br) (branch-torque right-br))
		(balanced? (branch-structure left-br))
		(balanced? (branch-structure right-br)))))))
(define (branch-torque branch)
  (if (has-weight? branch)
      (* (branch-length branch) (branch-structure branch))
      (* (branch-length branch) (total-weight (branch-structure branch)))))
;;;balanced testing mobile
(define bm4bl (make-branch 2 3))
(define bm4br (make-branch 1 6))
(define bm4 (make-mobile bm4bl bm4br))
(define bm3bl (make-branch 2 9))
(define bm3br (make-branch 2 bm4))
(define bm3 (make-mobile bm3bl bm3br))
;;;d.
;;;Mapping over trees
(define (scale-tree tree factor)
  (cond ((null? tree) '())
	((not (pair? tree)) (* tree factor))
	(else (cons (scale-tree (car tree) factor)
		    (scale-tree (cdr tree) factor)))))
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
	 (if (pair? sub-tree)
	     (scale-tree sub-tree factor)
	     (* sub-tree factor)))
       tree))
;;Exercise 2.30
(define (square-tree tree)
  (cond ((null? tree) '())
	((not (pair? tree)) (square tree))
	(else (cons (square-tree (car tree))
		    (square-tree (cdr tree))))))
(define (square-tree tree)
  (map (lambda (sub-tree)
	 (if (pair? sub-tree)
	     (square-tree sub-tree)
	     (square sub-tree)))
       tree))
;;Exercise 2.31.
(define (tree-map proc tree)
  (map (lambda (sub-tree)
	 (if (pair? sub-tree)
	     (tree-map proc sub-tree)
	     (proc sub-tree)))
       tree))
(define (square-tree tree)
  (tree-map square tree))
;;Exercise 2.32.
(define (subsets s)
  (if (null? s)
      '(())
      (let ((rest (subsets (cdr s))))
	(append rest (map (lambda (x) (cons (car s) x)) rest)))))
;;2.2.3 Sequences as Conventional Interfaces
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
	((not (pair? tree))
	 (if (odd? tree) (square tree) 0))
	(else (+ (sum-odd-squares (car tree))
		 (sum-odd-squares (cdr tree))))))
(define (even-fibs n)
  (define (next k)
    (if (> k n)
	'()
	(let ((f (fib k)))
	  (if (even? f)
	      (cons f (next (+ k 1)))
	      (next (+ k 1))))))
  (next 0))
(define (fib n)
  (cond ((= n 0) 0)
    ((= n 1) 1)
    (else (+ (fib (- n 1))
         (fib (- n 2))))))
;;;Sequence Operations
(define (filter predicate sequence)
  (cond ((null? sequence) '())
	((predicate (car sequence))
	 (cons (car sequence) (filter predicate (cdr sequence))))
	(else (filter predicate (cdr sequence)))))
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
	  (accumulate op initial (cdr sequence)))))
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))
(define enumerate-tree fringe)
(define (sum-odd-squares tree)
  (accumulate +
	      0
	      (map square
		   (filter odd? (enumerate-tree tree)))))
(define (even-fibs n)
  (accumulate cons
	      '()
	      (map fib (enumerate-interval 0 n))))
(define (list-fib-squares n)
  (accumulate cons
	      '()
	      (map square
		   (map fib
			(enumerate-interval 0 n)))))
(define (product-of-squares-of-odd-elements sequence)
  (accumulate *
	      1
	      (map square
		   (filter odd? sequence))))
;;Exercise 2.33.
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) '() sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))
;;Exercise 2.34.
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
		(+ this-coeff (* x higher-terms)))
	      0
	      coefficient-sequence))
;;Exercise 2.35.
(define (count-leaves t)
  (accumulate (lambda (x y) (+ 1 y))
	      0
	      (fringe t)))
;;Exercise 2.36.
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map car seqs))
	    (accumulate-n op init (map cdr seqs)))))
;;Exercise 2.37.
(unbind-variable (the-environment) 'map)
(define m1 '((1 -1 2) (0 -3 1)))
(define m2 '((1 2 3) (4 5 6)))
(define m3 '((7 8) (9 10) (11 12)))
(define v1 '(2 1 0))
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (lambda (row) (dot-product row v)) m))
(define (transpose mat)
  (accumulate-n cons '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (row)
	   (map (lambda (col)
		  (dot-product row col))
		cols))
	 m)))
;;Exercise 2.38.
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
	result
	(iter (op result (car rest))
	      (cdr rest))))
  (iter initial sequence))
(define fold-right accumulate)
;;(fold-right / 1 '(1 2 3)) -> 3/2
;;(fold-left / 1 '(1 2 3)) -> 1/6
;;(fold-right list nil '(1 2 3)) -> 
;;(fold-left list nil '(1 2 3)) -> (() 1 2 3)
;;commutative
;;Exercise 2.39.
(define (reverse sequence)
  (fold-right (lambda (x y) (append y (list x))) '() sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) (cons y x)) '() sequence))
;;;Nested Mappings
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
	((divides? test-divisor n) test-divisor)
	(else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
	       (enumerate-nested-intervals n))))
(define (enumerate-nested-intervals n)
  (flatmap (lambda (i)
	     (map (lambda (j) (list i j))
		  (enumerate-interval 1 (- i 1))))
	   (enumerate-interval 1 n)))
(define (permutations s)
  (if (null? s)
      '(())
      (flatmap (lambda (x)
		 (map (lambda (p) (cons x p))
		      (permutations (remove x s))))
	       s)))
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
	  sequence))
;;Exercise 2.40.
(define unique-pairs enumerate-nested-intervals)
;;Exercise 2.41.
(define (unique-triplets n)
  (flatmap (lambda (x)
	     (map (lambda (pairs) (cons x pairs))
		  (unique-pairs (- x 1))))
	   (enumerate-interval 1 n)))
(define (sum-triplets n s)
  (filter (lambda (triplet)
	    (= s
	       (+ (car triplet) (cadr triplet) (caddr triplet))))
	  (unique-triplets n)))
;;Exercise 2.42.
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
	(list empty-board)
	(filter
	 (lambda (positions) (safe? k positions))
	 (flatmap
	  (lambda (rest-of-queens)
	    (map (lambda (new-row)
		   (adjoin-position new-row k rest-of-queens))
		 (enumerate-interval 1 board-size)))
	  (queen-cols (- k 1))))))
  (queen-cols board-size))
(define empty-board '())
(define (safe? k positions)
  (define (iter new-queen-row rest-of-queens)
    (if (null? rest-of-queens)
	true
	(let ((current-col (length rest-of-queens))
	      (current-row (car rest-of-queens)))
	  (cond ((null? rest-of-queens) true)
		((= new-queen-row current-row) false)
		((or (= current-row (+ new-queen-row (- k current-col)))
		     (= current-row (- new-queen-row (- k current-col))))
		 false)
		(else (iter new-queen-row (cdr rest-of-queens)))))))
  (iter (car positions) (cdr positions)))
(define (adjoin-position new-row k rest-of-queens)
  (cons new-row rest-of-queens))
;;Exercise 2.43.
;;2.2.4 Example: A Picture Langugage
;;;This section has been completed. However, it was removed since not all
;;;definitions are evaluable.
;Lecture: Aggregate Data
(define (last lst)
  (cond ((null? lst) '())
	((null? (cdr lst)) (car lst))
	(else (last (cdr lst)))))
;2.3 Symbolic Data
(define (memq item x)
  (cond ((null? x) false)
	((eq? item (car x)) x)
	(else (memq item (cdr x)))))
;;Exercise 2.53.
;;;(list 'a 'b 'c) -> (a b c)
;;;(list (list 'george)) -> ((george))
;;;(cdr '((x1 x2) (y1 y2))) -> ((y1 y2))
;;;(cadr '((x1 x2) (y1 y2))) -> (y1 y2)
;;;(pair? (car '(a short list))) -> #f
;;;(memq 'red '((red shoes) (blue socks))) -> #f
;;;(memq 'red '(red shoes blue socks)) -> (red shoes blue socks)
;;Exercise 2.54.
(define (equal-list? lst1 lst2)
  (cond ((and (null? lst1) (null? lst2)) true)
	((or (null? lst1) (null? lst2)) false)
	(else (and (eq? (car lst1) (car lst2))
		   (equal-list? (cdr lst1) (cdr lst2))))))
;;Exercise 2.55.
;;;(car (quote (quote abracadabra)))
;;2.3.2 Example: Symbolic Differentiation
;;;The differentiation program with abstract data
(define (deriv exp var)
  (cond ((number? exp) 0)
	((variable? exp)
	 (if (same-variable? exp var) 1 0))
	((sum? exp)
	 (make-sum (deriv (addend exp) var)
		   (deriv (augend exp) var)))
	((product? exp)
	 (make-sum
	  (make-product (multiplier exp)
			(deriv (multiplicand exp) var))
	  (make-product (deriv (multiplier exp) var)
			(multiplicand exp))))
	((exponentiation? exp)
	 (make-product
	  (make-product (exponent exp)
			(make-exponentiation (base exp)
					     (- (exponent exp) 1)))
	  (deriv (base exp) var)))
	(else
	 (error "unknown expression type -- DERIV" exp))))
;;;Representing algebraic expressions
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s)
  (let ((rest (cddr s)))
    (if (= (length rest) 1)
	(car rest)
	(cons '+ rest))))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p)
  (let ((rest (cddr p)))
    (if (= (length rest) 1)
	(car rest)
	(cons '* rest))))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
	((=number? a2 0) a1)
	((and (number? a1) (number? a2)) (+ a1 a2))
	((and (sum? a1) (not (sum? a2)))
	 (cons '+ (append (cdr a1) (list a2))))
	((and (not (sum? a1)) (sum? a2))
	 (cons '+ (append (list a1) (cdr a2))))
	((and (sum? a1) (sum? a2))
	 (cons '+ (append (cdr a1) (cdr a2))))
	(else (list '+ a1 a2))))
(define (=number? e num)
  (and (number? e) (= e num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	((=number? m1 1) m2)
	((=number? m2 1) m1)
	((and (number? m1) (number? m2)) (* m1 m2))
	((and (product? m1) (not (product? m2)))
	 (cons '* (append (cdr m1) (list m2))))
	((and (not (product? m1)) (product? m2))
	 (cons '* (append (list m1) (cdr m2))))
	((and (product? m1) (product? m2))
	 (cons '* (append (cdr m1) (cdr m2))))
	(else (list '* m1 m2))))
;;Exercise 2.56.
(define (make-exponentiation b e)
  (cond ((=number? b 0) 0)
	((=number? b 1) 1)
	((=number? e 0) 1)
	((=number? e 1) b)
	(else (list '** b e))))
(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))
(define (base e) (cadr e))
(define (exponent e) (caddr e))
;;Exercise 2.57.
;;;see latest constructors and selectors above
;;Exercise 2.58.
;;;a.
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
	((=number? a2 0) a1)
	((and (number? a1) (number? a2)) (+ a1 a2))
	(else (list a1 '+ a2))))
(define (addend s) (car s))
(define (augend s)
  (caddr s))
(define (sum? x)
  (and (pair? x)
       (= (length x) 3)
       (eq? (cadr x) '+)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	((=number? m1 1) m2)
	((=number? m2 1) m1)
	((and (number? m1) (number? m2)) (* m1 m2))
	(else (list m1 '* m2))))
(define (multiplier p) (car p))
(define (multiplicand p)
  (let ((rest (cddr p)))
    (if (= (length rest) 1)
	(car rest)
	(cons '* rest))))
(define (product? x)
  (and (pair? x)
       (= (length x) 3)
       (eq? (cadr x) '*)))
;;;b.
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
	((=number? a2 0) a1)
	((and (number? a1) (number? a2)) (+ a1 a2))
	((and (sum? a1) (not (sum? a2)))
	 (if (product? a2)
	     (append-multi a1 '(+) a2)
	     (append-multi a1 '(+) (list a2))))
	((and (not (sum? a1)) (sum? a2))
	 (if (product? a1)
	     (append-multi a1 '(+) a2)
	     (append-multi (list a1) '(+) a2)))
	((and (sum? a1) (sum? a2))
	 (append-multi a1 '(+) a2))
	(else (append-multi (list a1) '(+) (list a2)))))
(define (sum? x)
  (and (pair? x) (not (not (memq '+ x)))))
(define (augend s)
  (right-from-symbol '+ s))
(define (addend s)
  (left-till-symbol '+ s))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	((=number? m1 1) m2)
	((=number? m2 1) m1)
	((and (number? m1) (number? m2)) (* m1 m2))
	((and (product? m1) (not (product? m2)))
	 (append-multi m1 '(*) (list m2)))
	((and (not (product? m1)) (product? m2))
	 (append-multi (list m1) '(*) m2))
	((and (product? m1) (product? m2))
	 (append-multi m1 '(*) m2))
	(else (list m1 '* m2))))
(define (product? x)
  (and (pair? x)
       (not (sum? x))
       (not (not (memq '* x)))))
(define (multiplier p)
  (left-till-symbol '* p))
(define (multiplicand p)
  (right-from-symbol '* p))
(define (left-till-symbol symbol x)
  (let ((left-term (car (memq symbol x))))
    (single-elem-or-list left-term)))
(define (right-from-symbol symbol x)
  (let ((right-term (cdr (memq symbol x))))
    (single-elem-or-list right-term)))
(define (single-elem-or-list x)
  (if (= (length x) 1)
      (car x)
      x))
(define (left-memq item x)
  (define (iter x res)
    (cond ((and (null? x) (null? res) #f))
	  ((eq? item (car x)) res)
	  (else (iter (cdr x) (append res (list (car x)))))))
  (iter x '()))
(define (append-multi . args)
  (define (iter res args)
    (if (null? args)
	res
	(iter (append res (car args)) (cdr args))))
  (iter '() args))
;;2.3.3 Example: Representing Sets
;;;Sets as unordered lists
(define (element-of-set? x set)
  (cond ((null? set) false)
	((equal? x (car set)) true)
	(else (element-of-set? x (cdr set)))))
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
	((element-of-set? (car set1) set2)
	 (cons (car set1)
	       (intersection-set (cdr set1) set2)))
	(else (intersection-set (cdr set1) set2))))
;;Exercise 2.59.
(define (union-set set1 set2)
  (if (null? set1)
      set2
      (let ((union-cdr (union-set (cdr set1) set2)))
	(if (element-of-set? (car set1) union-cdr)
	    union-cdr
	    (cons (car set1) union-cdr)))))
;;Exercise 2.60.
;;;`element-of-set?' and `intersection-set' stay the same.
(define (adjoin-set x set)
  (cons x set))
(define (union-set set1 set2)
  (append set1 set2))
;;;Sets as ordered lists
(define (element-of-set? x set)
  (cond ((null? set) false)
	((< x (car set)) false)
	(else (element-of-set? x (cdr set)))))
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
	(cond ((= x1 x2)
	       (cons x1
		     (intersection-set (cdr set1) (cdr set2))))
	      ((< x1 x2)
	       (intersection-set (cdr set1) set2))
	      ((< x2 x1)
	       (intersection-set set1 (cdr set2)))))))
;;Exercise 2.61.
(define (adjoin-set x set)
  (cond ((null? set) (cons x set))
	((< x (car set)) (cons x set))
	((= x (car set)) set)
	(else (cons (car set)
		    (adjoin-set x (cdr set))))))
;;Exercise 2.62.
(define (union-set set1 set2)
  (cond ((null? set1) set2)
	((null? set2) set1)
	(else (let ((x1 (car set1)) (x2 (car set2)))
		(cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
		      ((< x1 x2) (cons x1 (union-set (cdr set1) set2)))
		      ((< x2 x1) (cons x2 (union-set set1 (cdr set2)))))))))
;;Sets as binary trees
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
(define (element-of-set? x set)
  (cond ((null? set) false)
	((= x (entry set)) true)
	((< x (entry set))
	 (element-of-set? x (left-branch set)))
	((> x (entry set))
	 (element-of-set? x (right-branch set)))))
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
	((= x (entry set)) set)
	((< x (entry-set))
	 (make-tree (entry set)
		    (adjoin-set x (left-branch set))
		    (right-branch set)))
	((> x (entry-set))
	 (make-tree (entry set)
		    (left-branch set)
		    (adjoin-set x (right-branch set))))))
;;Exercise 2.63.
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
	      (cons (entry tree)
		    (tree->list-1 (right-branch tree))))))
(define (tree->list-2 tree)
  (copy-to-list tree '()))
(define (copy-to-list tree result-list)
  (if (null? tree)
      result-list
      (copy-to-list (left-branch tree)
		    (cons (entry tree)
			  (copy-to-list (right-branch tree)
					result-list)))))
(define t20 (make-tree 1 '() '()))
(define t21 (make-tree 5 '() '()))
(define t10 (make-tree 3 t20 t21))
(define t22 (make-tree 11 '() '()))
(define t11 (make-tree 9 '() t22))
(define tree1 (make-tree 7 t10 t11))
;;;a. Yes.
;;;b. `tree->list-1' has O(nlogn) growth; `tree->list-2' has O(n) growth.
;;Exercise 2.64.
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
	(let ((left-result (partial-tree elts left-size)))
	  (let ((left-tree (car left-result))
		(non-left-elts (cdr left-result))
		(right-size (- n (+ left-size 1))))
	    (let ((this-entry (car non-left-elts))
		  (right-result (partial-tree (cdr non-left-elts)
					      right-size)))
	      (let ((right-tree (car right-result))
		    (remaining-elts (cdr right-result)))
		(cons (make-tree this-entry left-tree right-tree)
		      remaining-elts))))))))
;;;a. On a high level and recursively, `partial-tree' works by first divide up
;;;   the list into two parts, `left' and `right', which correspond to the
;;;   left and right branch, respectively, of the to-be-formed tree. It then
;;;   calls itself recursively to form a balanced tree on the left, excluding
;;;   the first element reserved to be the `entry'; calls itself recursively
;;;   to form a balanced tree on the right with the remaining elements; and
;;;   finally calls `make-tree' to glue `left', `entry', and `right' together.
;;;b. O(n)
;;Exercise 2.65.
(define (list-tree->b-tree-helper proc tree1 tree2)
  (list->tree
   (proc (tree->list-2 tree1)
	 (tree->list2 tree2))))
(define (union-set-btree tree1 tree2)
  (list-tree->b-tree-helper union-set tree1 tree2))
(define (intersection-set-btree tree1 tree2)
  (list-tree->b-tree-helper intersction-set tree1 tree2))
;;;Sets and information retrieval
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
	((equal? given-key (key (car set-of-records)))
	 (car set-of-records))
	(else (lookup given-key (cdr set-of-records)))))
;;Exercise 2.66.
(define (lookup given-key set-of-records)
  (if (null? set-of-records)
      false
      (let ((lookup-key (key (entry set-of-records))))
	(cond ((= lookup-key given-key) (entry set-of-records))
	      ((> lookup-key given-key)
	       (lookup given-key (left-branch set-of-records)))
	      ((< lookup-key given-key)
	       (lookup given-key (right-branch set-of-records)))))))
;;2.3.4 Example: Huffman Encoding Trees
;;;Generating Huffman trees
;;;Representing Huffman trees
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
(define (make-code-tree left right)
  (list left
	right
	(append (symbols left) (symbols right))
	(+ (weight left) (weight right))))
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
;;;The decoding procedure
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
	'()
	(let ((next-branch
	       (choose-branch (car bits) current-branch)))
	  (if (leaf? next-branch)
	      (cons (symbol-leaf next-branch)
		    (decode-1 (cdr bits) tree))
	      (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
	((= bit 1) (right-branch branch))
	(else (error "bad bit -- CHOOSE-BRANCH" bit))))
;;;Sets of weighted elements
(define (adjoin-set x set)
  (cond ((null? set) (list x))
	((< (weight x) (weight (car set))) (cons x set))
	(else (cons (car set)
		    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
	(adjoin-set (make-leaf (car pair)
			       (cadr pair))
		    (make-leaf-set (cdr pairs))))))
;;Exercise 2.67.
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
;;Exercise 2.68.
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
	      (encode (cdr message) tree))))
(define (encode-symbol symbol tree)
  (define (helper result tree)
    (if (or (null? tree) (leaf? tree))
	(error "symbol not in tree -- ENCODE-SYMBOL" symbol)
	(let ((left (left-branch tree))
	      (right (right-branch tree)))
	  (let ((left-symbol (symbols left))
		(right-symbol (symbols right)))
	    (cond ((and (leaf? left) (memq symbol left-symbol))
		   (append result '(0)))
		  ((and (leaf? right) (memq symbol right-symbol))
		   (append result '(1)))
		  ((memq symbol left-symbol)
		   (helper (append result '(0)) left))
		  ((memq symbol right-symbol)
		   (helper (append result '(1)) right)))))))
  (helper '() tree))
;;Exercise 2.69.
(define rock-leaves
  (make-leaf-set '((A 2) (BOOM 1) (GET 2) (JOB 2)
		   (NA 16) (SHA 3) (YIP 9) (WAH 1))))
(define sample-leaves
  (make-leaf-set '((A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1))))
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
(define (successive-merge leaves)
  (cond ((null? leaves) '())
	((= (length leaves) 1) (car leaves))
	(else
	 (let ((first (car leaves))
	       (second (cadr leaves)))
	   (successive-merge (adjoin-set (make-code-tree first second)
					 (cddr leaves)))))))
;;Exercise 2.70.
(define rock-tree (successive-merge rock-leaves))
(define rock-encoded
  (encode '(Get a job Sha na na na na na na na na
		Get a job Sha na na na na na na na na
		Wah yip yip yip yip yip yip yip yip yip
		Sha boom
	   )
	  rock-tree))
;;;84 bits are required.
;;;If fixed length, 8 words to represent -> log_2{8} = 3 bits each word.
;;;Total 36 words = 108 bits.
;;Exercise 2.71.
;;Exercise 2.72.
;2.4 Multiple Representations for Abstract Data
;;2.4.1 Representations for Complex Numbers
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
		       (+ (imag-part z1) (imag-part z2))))
(define (sub-complex z1 x2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
		       (- (imag-part z1) (imag-part z2))))
(define (mul-complex z1 x2)
  (make-from-mag-ang (* (magnitute z1) (magnitude z2))
		     (+ (angle z1) (angle z2))))
(define (div-complex z1 x2)
  (make-from-mag-ang (/ (magnitute z1) (magnitude z2))
		     (- (angle z1) (angle z2))))
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))
(define (angle z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y) (cons x y))
(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))
(define (real-part z)
  (* (magnitude z) (cos (angle z))))
(define (imag-part z)
  (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))
(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
	(atan y x)))
(define (make-from-mag-ang r a) (cons r a))
;;2.4.2 Tagged data
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum -- TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum -- CONTENTS" datum)))
(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
(define (polar? z)
  (eq? (type-tag z) 'polar))
(define (real-part-rectangular) (car z))
(define (imag-part-rectangular) (cdr z))
(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
	   (square (imag-part-rectangular z)))))
(define (angle-rentangular z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
(define (make-from-mag-ang-rectangular r a)
  (attach-tag 'rectangular (cons (* r (cos a)) (* r (sin a)))))
(define (real-part-polar z)
  (* (magnitude z) (cos (angle z))))
(define (imag-part-polar z)
  (* (magnitude z) (sin (angle z))))
(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))
(define (make-from-real-imag-polar x y)
  (attach-tag 'polar (cons (sqrt (+ (square x) (square y)))
			   (atan y x))))
(define (make-from-mag-ang-polar r a) (attach-tag 'polar (cons r a)))
(define (real-part z)
  (cond ((rectangular? z)
	 (real-part-rectangular (contents z)))
	((polar? z)
	 (real-part-polar (contents z)))
	(else (error "Unknown type -- REAL-PART" z))))
(define (imag-part z)
  (cond ((rectangular? z)
	 (imag-part-rectangular (contents z)))
	((polar? z)
	 (imag-part-polar (contents z)))
	(else (error "Unknown type -- IMAG-PART" z))))
(define (magnitude z)
  (cond ((rectangular? z)
	 (magnitude-rectangular (contents z)))
	((polar? z)
	 (magnitude-polar (contents z)))
	(else (error "Unknown type -- MAGNITUDE" z))))
(define (angle z)
  (cond ((rectangular? z)
	 (angle-rectangular (contents z)))
	((polar? z)
	 (angle-polar (contents z)))
	(else (error "Unknown type -- ANGLE" z))))
(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
;;2.4.3 Data-Directed Programming and Additivity
(define (square x)
  (mul x x))
(define *op-table* (make-hash-table))
(define (put op type proc)
  (hash-table/put! *op-table* (list op type) proc))
(define (get op type)
  (hash-table/get *op-table* (list op type) #f))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (add (square (real-part z))
               (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
	  (apply proc (map contents args))
	  (error
	   "No method for these types -- APPLY-GENERIC"
	   (list op type-tags))))))
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
;;Exercise 2.73.
(define (deriv exp var)
  (cond ((number? exp) 0)
	((variable? exp) (if (same-variable? exp var) 1 0))
	(else ((get 'deriv (operator exp)) (operands exp) var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (make-sum t1 t2)
  (list '+ t1 t2))
(define (make-product t1 t2)
  (list '* t1 t2))
(define (install-deriv-package)
  ;;interval procedures
  (define (deriv-sum operands var)
    (make-sum (deriv (car operands) var)
	      (deriv (cadr operands) var)))
  (define (deriv-product operands var)
    (make-sum
     (make-product (car operands)
		   (deriv (cadr operands) var))
     (make-product (deriv (car operands) var)
		   (cadr operands))))
  ;;interface to the rest of the system
  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product)
  'done)
;;Exercise 2.74.
(define (get-record employee file)
  ((get 'get-record (division file)) (id employee) file))
(define (get-salary record)
  ((get 'get-salary (division record)) record))
(define (find-employee-record name files)
  (if (null? files)
      false
      (let ((curr-result ((get 'get-record (division (car files)))
			  employee)))
	(if curr-result
	    curr-result
	    (find-employee-record name (cdr files))))))
;;;Message passing
;; (define (make-from-real-imag x y)
;;   (define (dispatch op)
;;     (cond ((eq? op 'real-part) x)
;; 	  ((eq? op 'imag-part) y)
;; 	  (else
;; 	   (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
;;   dispatch)
;;Exercise 2.75.
;;Exercise 2.76.
;2.5 Systems with Generic Operations
;;2.5.1 Generic Arithmetic Operations
(define (add . args)
  (if (> (length args) 2)
	  (add (car args)
		   (add (cdr args)))))
(define (type-hierarchy x) (apply-generic 'type-hierarchy x))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (project x) (apply-generic 'project x))
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (define (raise x)
	(make-rational x 1))
  (define (type-hierarchy x) 0)
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'raise '(scheme-number) raise)
  (put 'type-hierarchy '(scheme-number) type-hierarchy)
  'done)nn
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (equ? x y)
    (and (= (numer x) (numer y))
		 (= (denom x) (denom y))))
  (define (raise x)
	(make-from-real-imag (/ (numer x) (denom x)) 0))
  (define (type-hierarchy x) 1)
  (define (project x) (numer x))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'equ? '(rational rational) equ?)
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'raise '(rational) raise)
  (put 'type-hierarchy '(rational) type-hierarchy)
  (put 'project '(rational) project)
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; interval procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  (define (equ? z1 z2)
    (and (= (real-part z1) (real-part z2))
		 (= (imag-part z1) (imag-part z2))))
  (define (type-hierarchy z) 2)
  (define (project z)
	(make-rational (drop (real-part z)) 1))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'complex x))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) equ?)
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'type-hierarchy '(complex) type-hierarchy)
  (put 'project '(complex) project)
  'done)
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
;;Exercise 2.77.
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
;;Exercise 2.78.
(define (type-tag datum)
  (cond ((number? datum) 'scheme-number)
	((pair? datum) (car datum))
	(else "Bad tagged datum -- TYPE-TAG" datum)))
(define (contents datum)
  (cond ((number? datum) datum)
	((pair? datum) (cdr datum))
	(else "Bad tagged datum -- TYPE-TAG" datum)))
(define (attach-tag type-tag contents)
  (if (number? contents)
      contents
      (cons type-tag contents)))
(define (install-scheme-number-package)
  (put 'add '(scheme-number scheme-number) +)
  (put 'sub '(scheme-number scheme-number) -)
  (put 'mul '(scheme-number scheme-number) *)
  (put 'div '(scheme-number scheme-number) /)
  (put 'equ? '(scheme-number scheme-number) =)
  'done)
;;Exercise 2.79.
(define (equ? x y)
  (apply-generic 'equ? x y))
;;Exercise 2.80.
;;2.5.2 Combining Data of Different Types
;;;Coercion
(define *coercion-table* (make-hash-table))
(define (put-coercion from-type to-type proc)
  (hash-table/put! *coercion-table* (list from-type to-type) proc))
(define (get-coercion from-type to-type)
  (hash-table/get *coercion-table* (list from-type to-type) #f))
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
	(let ((proc (get op type-tags)))
	  (if proc
		  (apply proc (map contents args))
		  (if (= (length args 2))
			  (let ((type1 (car type-tags))
					(type2 (cadr type-tags))
					(a1 (car args))
					(a2 (cadr args)))
				(let ((t1->t2 (get-coercion t1 t2))
					  (t2->t1 (get-coercion t2 t1)))
				  (cond ((t1->t2
						  (apply-generic op (t1->t2 a1) a2)))
						((t2->t1
						  (apply-generic op a1 (t2->t1 a2))))
						(else
						 (error "No method for these types"
								(list op type-tags))))))
			  (error "No method for these types"
					 (list op type-tags)))))))
;;;Hierarchies of types
;;;Inadequacies of hierarchies
;;Exercise 2.81.
(install-scheme-number-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(define (install-coercion-package)
  ;;;internal procedures
  (define (scheme-number->rational x)
	(make-rational (contents x) 1))
  (define (rational->complex x)
	(make-from-real-imag (/ (numer (contents x))
							(denom (contents x)))
						 0))
  (put-coercion 'scheme-number 'rational scheme-number->rational)
  (put-coercion 'rational 'complex rational->complex)
  'done)
(install-coercion-package)
;;;a. Infinite loop
;;;b. `apply-generic' works as is; but it does try to coerce same types when
;;;it could not find `op'.
;;;c.
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
	(let ((proc (get op type-tags)))
	  (if proc
		  (apply proc (map contents args))
		  (if (= (length args 2))
			  (let ((type1 (car type-tags))
					(type2 (cadr type-tags))
					(a1 (car args))
					(a2 (cadr args)))
				(if (eq? type1 type2)
					(error "No method for these types"
						   (list op type-tags))
					(let ((t1->t2 (get-coercion t1 t2))
						  (t2->t1 (get-coercion t2 t1)))
					  (cond ((t1->t2
							  (apply-generic op (t1->t2 a1) a2)))
							((t2->t1
							  (apply-generic op a1 (t2->t1 a2))))
							(else
							 (error "No method for these types"
									(list op type-tags)))))))
			  (error "No method for these types"
					 (list op type-tags)))))))
;;Exercise 2.82.
(define (apply-generic op . args)
  (if (> (length args) 2)
	  (apply-generic op
					 (car args)
					 (apply apply-generic (append (list op) (cdr args))))
	  (let ((type-tags (map type-tag args)))
		(let ((proc (get op type-tags)))
		  (if proc
			  (apply proc (map contents args))
			  (let ((new-args (try-coercion args type-tags)))
				(if (not (null? new-args))
					(apply apply-generic (append (list op) new-args))
					(error "No method for these types"
						   (list op type-tags)))))))))
(define (try-coercion args type-tags)
  (define (helper args type-tags to-try-type-tags)
	(if (null? to-try-type-tags)
		false
		(let ((target-type-tag (car to-try-type-tags)))
		  (let ((new-args (coerce-args args type-tags target-type-tag)))
			(if (not (null? new-args))
				new-args
				(helper args type-tags (cdr to-try-type-tags)))))))
  (helper args type-tags type-tags))
(define (coerce-args args type-tags target-type-tag)
  (define (helper args type-tags coerced-args)
	(cond ((null? args) coerced-args)
		  ((eq? (car type-tags) target-type-tag)
		   (helper (cdr args)
				   (cdr type-tags)
				   (append coerced-args (list (car args)))))
		  (else
		   (let ((coercion-proc
				  (get-coercion (car type-tags) target-type-tag)))
			 (if coercion-proc
				 (helper (cdr args)
						 (cdr type-tags)
						 (append coerced-args
								 (list (coercion-proc (car args)))))
				 '())))))
  (helper args type-tags '()))
;;Exercise 2.83.
(define (raise x) (apply-generic 'raise x))
;;Exercise 2.84.
(define (try-raise args type-tags)
  (let ((type-hierarchies (map type-hierarchy args)))
	(let ((highest-hierarchy (apply max type-hierarchies)))
	  (define (helper args type-hierarchies new-args)
		(if (null? args)
			new-args
			(helper (cdr args)
					(cdr type-hierarchies)
					(cons ((repeated raise
									 (- highest-hierarchy
										(car type-hierarchies)))
						   (car args))
						  new-args))))
	  (helper args type-hierarchies '()))))
(define (apply-generic-transform type-transform op args)
  (let ((type-tags (map type-tag args)))
	(let ((proc (get op type-tags)))
	  (if proc
		  (apply proc (map contents args))
		  (let ((new-args (type-transform args type-tags)))
			(if (not (null? new-args))
				(apply-generic-transform type-transform op new-args)
				(error "No method for these types"
					   (list op type-tags))))))))
(define (apply-generic-coercion op args)
  (apply-generic-transform try-coercion op args))
(define (apply-generic-raise op args)
  (apply-generic-transform try-raise op args))
(define (repeated p n)
  (cond ((= n 0) (lambda (x) x))
	((= n 1) p)
	(else (lambda (x) (p ((repeated p (- n 1)) x))))))
(define (add . args)
  (if (> (length args) 2)
	  (add (car args)
		   (apply add (cdr args)))
	  (apply-generic-raise 'add args)))
;;Exercise 2.85.
(define (drop x)
  (let ((project-proc (get 'project (list (type-tag x)))))
	(if project-proc
		(let ((projected (project x)))
		  (if (equ? (raise projected) x)
			  (drop projected)
			  x))
		x)))
;;Exercise 2.86.
;;; Very messy.
;;2.5.3 Example: Symbolic Algebra
;;;Arithmetic on polynomials
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))










	  (make-poly (variable p1)
				 (add-terms (term-list p1)
							(term-list p2)))
	  (error "Polys not in same var -- ADD-POLY"
			 (list p1 p2))))
(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
				 (mul-terms (term-list p1)
							(term-list p2)))
	  (error "Polys not in same var -- ADD-POLY"
			 (list p1 p2))))
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
	(cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (add-poly p1 p2))
  (define (mul-poly p1 p2))
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
	   (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
	   (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
	   (lambda (var terms) (tag (make-poly var terms))))
  'done)
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
		((empty-termlist? L2) L1)
		(else
		 (let ((t1 (first-term L1)) (t2 (first-term L2)))
		   (cond ((> (order t1) (order t2))
				  (adjoin-term
				   t1 (add-terms (rest-terms L1) L2)))
				 ((< (order t1) (order t2))
				  (adjoin-term
				   t2 (add-terms L1 (rest-terms L2))))
				 (else
				  (adjoin-term
				   (make-term (order t1)
							  (add (coeff t1) (coeff t2)))
				   (add-terms (rest-terms L1)
							  (rest-terms L2)))))))))
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
	  (the-empty-termlist)
	  (add-terms (mul-term-by-all-terms (first-term L1) L2)
				 (mul-terms (rest-terms L1) L2))))
(define (mul-term-by-all-terms t1 L)
  (if (emty-termlist? L)
	  (the-emty-term-list)
	  (let ((t2 (first-term L)))
		(adjoin-term
		 (make-term (+ (order t1) (order t2))




					(mul (coeff t1) (coeff t2)))
		 (mul-term-by-all-terms t1 (rest-terms L))))))
;;;Representing term lists
(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
	  term-list
	  (cons term term-list)))
(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))
(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
